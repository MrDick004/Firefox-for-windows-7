

diff --git a/modules/libpref/init/StaticPrefList.yaml b/modules/libpref/init/StaticPrefList.yaml
index 14fbdc4208813..3c9b8f0f9d753 100644
--- a/modules/libpref/init/StaticPrefList.yaml
+++ b/modules/libpref/init/StaticPrefList.yaml
@@ -17266,6 +17266,19 @@
   value: 0
   mirror: always
 
+# Whether to apply a workaround intended to prevent Windows from treating
+# non-foreground-marked fullscreen windows as fullscreen on Windows 7 and
+# earlier. (See bug 1732517.)
+#
+# Valid values:
+#  * -1: the workaround is never used.
+#  *  1: the workaround is always used.
+#  *  0: the workaround is used if we think it should be. (Default.)
+- name: widget.windows.fullscreen_marking_workaround
+  type: RelaxedAtomicInt32
+  value: 0
+  mirror: always
+
 # The number of messages of each type to keep for display in
 # about:windows-messages
 - name: widget.windows.messages_to_log
diff --git a/tools/lint/mscom-init.yml b/tools/lint/mscom-init.yml
index f7d52285d4c08..e67ebbb55fa14 100644
--- a/tools/lint/mscom-init.yml
+++ b/tools/lint/mscom-init.yml
@@ -43,6 +43,7 @@ forbid-mscom-init:
         - toolkit/crashreporter/google-breakpad/src/common/windows/pdb_source_line_writer.cc
         - toolkit/mozapps/defaultagent/proxy/main.cpp
         - uriloader/exthandler/win/nsOSHelperAppService.cpp
+        - widget/windows/InkCollector.cpp
         - widget/windows/TaskbarPreview.cpp
         - widget/windows/WinTaskbar.cpp
         - widget/windows/nsAppShell.cpp
diff --git a/widget/tests/gtest/TestWinWindowOcclusionTracker.cpp b/widget/tests/gtest/TestWinWindowOcclusionTracker.cpp
index 5ef7e3f81ce25..b1f1114a3ad47 100644
--- a/widget/tests/gtest/TestWinWindowOcclusionTracker.cpp
+++ b/widget/tests/gtest/TestWinWindowOcclusionTracker.cpp
@@ -11,6 +11,7 @@
 
 #include "MockWinWidget.h"
 #include "mozilla/widget/WinWindowOcclusionTracker.h"
+#include "mozilla/WindowsVersion.h"
 
 using namespace mozilla;
 using namespace mozilla::widget;
@@ -153,6 +154,10 @@ TEST_F(WinWindowOcclusionTrackerTest, PopupWindow) {
 }
 
 TEST_F(WinWindowOcclusionTrackerTest, CloakedWindow) {
+  // Cloaking is only supported in Windows 8 and above.
+  if (!IsWin8OrLater()) {
+    return;
+  }
   HWND hwnd = CreateNativeWindow(/* aStyle = */ 0, /* aExStyle = */ 0);
   LayoutDeviceIntRect winRect;
   BOOL cloak = TRUE;
diff --git a/widget/windows/IMMHandler.cpp b/widget/windows/IMMHandler.cpp
index 2f64f93922533..6633892c37246 100644
--- a/widget/windows/IMMHandler.cpp
+++ b/widget/windows/IMMHandler.cpp
@@ -18,6 +18,7 @@
 #include "mozilla/MiscEvents.h"
 #include "mozilla/TextEvents.h"
 #include "mozilla/ToString.h"
+#include "mozilla/WindowsVersion.h"
 
 #ifndef IME_PROP_ACCEPT_WIDE_VKEY
 #  define IME_PROP_ACCEPT_WIDE_VKEY 0x20
@@ -223,7 +224,8 @@ bool IMMHandler::IsActiveIMEInBlockList() {
   // ATOK 2008 and ATOK 2009 crash when user just opens their open state.
   // ATOK 2010 isn't installable newly on Win 7 or later, but we have a lot of
   // crash reports.
-  if ((IsATOK2006Active() || IsATOK2007Active() || IsATOK2008Active() ||
+  if (IsWin8OrLater() &&
+      (IsATOK2006Active() || IsATOK2007Active() || IsATOK2008Active() ||
        IsATOK2009Active() || IsATOK2010Active())) {
     return true;
   }
diff --git a/widget/windows/InkCollector.cpp b/widget/windows/InkCollector.cpp
new file mode 100644
index 0000000000000..2fcd2ea77d877
--- /dev/null
+++ b/widget/windows/InkCollector.cpp
@@ -0,0 +1,247 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: set ts=2 sw=2 et tw=78:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#include "InkCollector.h"
+#include "nsDebug.h"
+#include "nsISupportsUtils.h"
+
+// Msinkaut_i.c and Msinkaut.h should both be included
+// https://msdn.microsoft.com/en-us/library/windows/desktop/ms695519.aspx
+#include <msinkaut_i.c>
+
+mozilla::StaticAutoPtr<InkCollector> InkCollector::sInkCollector;
+
+InkCollector::~InkCollector() {
+  Shutdown();
+  MOZ_ASSERT(!mCookie && !mEnabled && !mComInitialized && !mMarshaller &&
+             !mInkCollector && !mConnectionPoint && !mInkCollectorEvent);
+}
+
+void InkCollector::Initialize() {
+  // Possibly, we can use mConnectionPoint for checking,
+  // But if errors exist (perhaps COM object is unavailable),
+  // Initialize() will be called more times.
+  static bool sInkCollectorCreated = false;
+  if (sInkCollectorCreated) {
+    return;
+  }
+  sInkCollectorCreated = true;
+
+  // COM could get uninitialized due to previous initialization.
+  mComInitialized = SUCCEEDED(::CoInitialize(nullptr));
+
+  // Set up instance of InkCollectorEvent.
+  mInkCollectorEvent = new InkCollectorEvent();
+
+  // Set up a free threaded marshaler.
+  if (FAILED(::CoCreateFreeThreadedMarshaler(mInkCollectorEvent,
+                                             getter_AddRefs(mMarshaller)))) {
+    return;
+  }
+
+  // Create the ink collector.
+  if (FAILED(::CoCreateInstance(CLSID_InkCollector, NULL, CLSCTX_INPROC_SERVER,
+                                IID_IInkCollector,
+                                getter_AddRefs(mInkCollector)))) {
+    return;
+  }
+
+  // Set up connection between sink and InkCollector.
+  RefPtr<IConnectionPointContainer> connPointContainer;
+
+  // Get the connection point container.
+  if (SUCCEEDED(mInkCollector->QueryInterface(
+          IID_IConnectionPointContainer, getter_AddRefs(connPointContainer)))) {
+    // Find the connection point for Ink Collector events.
+    if (SUCCEEDED(connPointContainer->FindConnectionPoint(
+            __uuidof(_IInkCollectorEvents),
+            getter_AddRefs(mConnectionPoint)))) {
+      // Hook up sink to connection point.
+      if (SUCCEEDED(mConnectionPoint->Advise(mInkCollectorEvent, &mCookie))) {
+        OnInitialize();
+      }
+    }
+  }
+}
+
+void InkCollector::Shutdown() {
+  Enable(false);
+  if (mConnectionPoint) {
+    // Remove the connection of the sink to the Ink Collector.
+    mConnectionPoint->Unadvise(mCookie);
+    mCookie = 0;
+    mConnectionPoint = nullptr;
+  }
+  mInkCollector = nullptr;
+  mMarshaller = nullptr;
+  mInkCollectorEvent = nullptr;
+
+  // Let uninitialization get handled in a place where it got inited.
+  if (mComInitialized) {
+    CoUninitialize();
+    mComInitialized = false;
+  }
+}
+
+void InkCollector::OnInitialize() {
+  // Suppress all events to do not allow performance decreasing.
+  // https://msdn.microsoft.com/en-us/library/ms820347.aspx
+  mInkCollector->SetEventInterest(InkCollectorEventInterest::ICEI_AllEvents,
+                                  VARIANT_FALSE);
+
+  // Sets a value that indicates whether an object or control has interest in a
+  // specified event.
+  mInkCollector->SetEventInterest(
+      InkCollectorEventInterest::ICEI_CursorOutOfRange, VARIANT_TRUE);
+
+  // If the MousePointer property is set to IMP_Custom and the MouseIcon
+  // property is NULL, Then the ink collector no longer handles mouse cursor
+  // settings.
+  // https://msdn.microsoft.com/en-us/library/windows/desktop/ms700686.aspx
+  mInkCollector->put_MouseIcon(nullptr);
+  mInkCollector->put_MousePointer(InkMousePointer::IMP_Custom);
+
+  // This mode allows an ink collector to collect ink from any tablet attached
+  // to the Tablet PC. The Boolean value that indicates whether to use the mouse
+  // as an input device. If TRUE, the mouse is used for input.
+  // https://msdn.microsoft.com/en-us/library/ms820346.aspx
+  mInkCollector->SetAllTabletsMode(VARIANT_FALSE);
+
+  // Sets the value that specifies whether ink is rendered as it is drawn.
+  // VARIANT_TRUE to render ink as it is drawn on the display.
+  // VARIANT_FALSE to not have the ink appear on the display as strokes are
+  // made.
+  // https://msdn.microsoft.com/en-us/library/windows/desktop/dd314598.aspx
+  mInkCollector->put_DynamicRendering(VARIANT_FALSE);
+
+  // Set AutoRedraw to false to prevent repainting the ink when the window is
+  // invalidated.
+  mInkCollector->put_AutoRedraw(VARIANT_FALSE);
+}
+
+// Sets a value that specifies whether the InkCollector object collects pen
+// input. This property must be set to FALSE before setting or calling specific
+// properties and methods of the object.
+// https://msdn.microsoft.com/en-us/library/windows/desktop/ms701721.aspx
+void InkCollector::Enable(bool aNewState) {
+  if (aNewState != mEnabled) {
+    if (mInkCollector) {
+      if (SUCCEEDED(mInkCollector->put_Enabled(aNewState ? VARIANT_TRUE
+                                                         : VARIANT_FALSE))) {
+        mEnabled = aNewState;
+      } else {
+        NS_WARNING("InkCollector did not change status successfully");
+      }
+    } else {
+      NS_WARNING("InkCollector should be exist");
+    }
+  }
+}
+
+HWND InkCollector::GetTarget() { return mTargetWindow; }
+
+void InkCollector::SetTarget(HWND aTargetWindow) {
+  NS_ASSERTION(aTargetWindow, "aTargetWindow should be exist");
+  if (aTargetWindow && (aTargetWindow != mTargetWindow)) {
+    Initialize();
+    if (mInkCollector) {
+      Enable(false);
+      if (SUCCEEDED(mInkCollector->put_hWnd((LONG_PTR)aTargetWindow))) {
+        mTargetWindow = aTargetWindow;
+      } else {
+        NS_WARNING("InkCollector did not change window property successfully");
+      }
+      Enable(true);
+    }
+  }
+}
+
+void InkCollector::ClearTarget() {
+  if (mTargetWindow && mInkCollector) {
+    Enable(false);
+    if (SUCCEEDED(mInkCollector->put_hWnd(0))) {
+      mTargetWindow = 0;
+    } else {
+      NS_WARNING("InkCollector did not clear window property successfully");
+    }
+  }
+}
+
+uint16_t InkCollector::GetPointerId() { return mPointerId; }
+
+void InkCollector::SetPointerId(uint16_t aPointerId) {
+  mPointerId = aPointerId;
+}
+
+void InkCollector::ClearPointerId() { mPointerId = 0; }
+
+// The display and the digitizer have quite different properties.
+// The display has CursorMustTouch, the mouse pointer alway touches the display
+// surface. The digitizer lists Integrated and HardProximity. When the stylus is
+// in the proximity of the tablet its movements are also detected. An external
+// tablet will only list HardProximity.
+bool InkCollectorEvent::IsHardProximityTablet(IInkTablet* aTablet) const {
+  if (aTablet) {
+    TabletHardwareCapabilities caps;
+    if (SUCCEEDED(aTablet->get_HardwareCapabilities(&caps))) {
+      return (TabletHardwareCapabilities::THWC_HardProximity & caps);
+    }
+  }
+  return false;
+}
+
+HRESULT __stdcall InkCollectorEvent::QueryInterface(REFIID aRiid,
+                                                    void** aObject) {
+  // Validate the input
+  if (!aObject) {
+    return E_POINTER;
+  }
+  HRESULT result = E_NOINTERFACE;
+  // This object supports IUnknown/IDispatch/IInkCollectorEvents
+  if ((IID_IUnknown == aRiid) || (IID_IDispatch == aRiid) ||
+      (DIID__IInkCollectorEvents == aRiid)) {
+    *aObject = this;
+    // AddRef should be called when we give info about interface
+    NS_ADDREF_THIS();
+    result = S_OK;
+  }
+  return result;
+}
+
+HRESULT InkCollectorEvent::Invoke(DISPID aDispIdMember, REFIID /*aRiid*/,
+                                  LCID /*aId*/, WORD /*wFlags*/,
+                                  DISPPARAMS* aDispParams,
+                                  VARIANT* /*aVarResult*/,
+                                  EXCEPINFO* /*aExcepInfo*/,
+                                  UINT* /*aArgErr*/) {
+  switch (aDispIdMember) {
+    case DISPID_ICECursorOutOfRange: {
+      if (aDispParams && aDispParams->cArgs) {
+        CursorOutOfRange(
+            static_cast<IInkCursor*>(aDispParams->rgvarg[0].pdispVal));
+      }
+      break;
+    }
+  }
+  return S_OK;
+}
+
+void InkCollectorEvent::CursorOutOfRange(IInkCursor* aCursor) const {
+  IInkTablet* curTablet = nullptr;
+  if (FAILED(aCursor->get_Tablet(&curTablet))) {
+    return;
+  }
+  // All events should be suppressed except
+  // from tablets with hard proximity.
+  if (!IsHardProximityTablet(curTablet)) {
+    return;
+  }
+  // Notify current target window.
+  if (HWND targetWindow = InkCollector::sInkCollector->GetTarget()) {
+    ::SendMessage(targetWindow, MOZ_WM_PEN_LEAVES_HOVER_OF_DIGITIZER, 0, 0);
+  }
+}
diff --git a/widget/windows/InkCollector.h b/widget/windows/InkCollector.h
new file mode 100644
index 0000000000000..803eeb48410ff
--- /dev/null
+++ b/widget/windows/InkCollector.h
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: set ts=2 sw=2 et tw=78:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+#ifndef InkCollector_h__
+#define InkCollector_h__
+
+#include <objbase.h>
+#include <msinkaut.h>
+#include "mozilla/StaticPtr.h"
+
+#define MOZ_WM_PEN_LEAVES_HOVER_OF_DIGITIZER WM_USER + 0x83
+
+class InkCollectorEvent final : public _IInkCollectorEvents {
+ public:
+  // IUnknown
+  HRESULT __stdcall QueryInterface(REFIID aRiid, void** aObject);
+  virtual ULONG STDMETHODCALLTYPE AddRef() { return ++mRefCount; }
+  virtual ULONG STDMETHODCALLTYPE Release() {
+    MOZ_ASSERT(mRefCount);
+    if (!--mRefCount) {
+      delete this;
+      return 0;
+    }
+    return mRefCount;
+  }
+
+ protected:
+  // IDispatch
+  STDMETHOD(GetTypeInfoCount)(UINT* aInfo) { return E_NOTIMPL; }
+  STDMETHOD(GetTypeInfo)(UINT aInfo, LCID aId, ITypeInfo** aTInfo) {
+    return E_NOTIMPL;
+  }
+  STDMETHOD(GetIDsOfNames)
+  (REFIID aRiid, LPOLESTR* aStrNames, UINT aNames, LCID aId, DISPID* aDispId) {
+    return E_NOTIMPL;
+  }
+  STDMETHOD(Invoke)
+  (DISPID aDispIdMember, REFIID aRiid, LCID aId, WORD wFlags,
+   DISPPARAMS* aDispParams, VARIANT* aVarResult, EXCEPINFO* aExcepInfo,
+   UINT* aArgErr);
+
+  // InkCollectorEvent
+  void CursorOutOfRange(IInkCursor* aCursor) const;
+  bool IsHardProximityTablet(IInkTablet* aTablet) const;
+
+ private:
+  uint32_t mRefCount = 0;
+
+  ~InkCollectorEvent() = default;
+};
+
+class InkCollector {
+ public:
+  ~InkCollector();
+  void Shutdown();
+
+  HWND GetTarget();
+  void SetTarget(HWND aTargetWindow);
+  void ClearTarget();
+
+  uint16_t GetPointerId();  // 0 shows that there is no existing pen.
+  void SetPointerId(uint16_t aPointerId);
+  void ClearPointerId();
+
+  static mozilla::StaticAutoPtr<InkCollector> sInkCollector;
+
+ protected:
+  void Initialize();
+  void OnInitialize();
+  void Enable(bool aNewState);
+
+ private:
+  RefPtr<IUnknown> mMarshaller;
+  RefPtr<IInkCollector> mInkCollector;
+  RefPtr<IConnectionPoint> mConnectionPoint;
+  RefPtr<InkCollectorEvent> mInkCollectorEvent;
+
+  HWND mTargetWindow = 0;
+  DWORD mCookie = 0;
+  bool mComInitialized = false;
+  bool mEnabled = false;
+
+  // This value holds the previous pointerId of the pen, and is used by the
+  // nsWindow when processing a MOZ_WM_PEN_LEAVES_HOVER_OF_DIGITIZER which
+  // indicates that a pen leaves the digitizer.
+
+  // TODO: If we move our implementation to window pointer input messages, then
+  // we no longer need this value, since the pointerId can be retrieved from the
+  // window message, please refer to
+  // https://msdn.microsoft.com/en-us/library/windows/desktop/hh454916(v=vs.85).aspx
+
+  // NOTE: The pointerId of a pen shouldn't be 0 on a Windows platform, since 0
+  // is reserved of the mouse, please refer to
+  // https://msdn.microsoft.com/en-us/library/windows/desktop/ms703320(v=vs.85).aspx
+  uint16_t mPointerId = 0;
+};
+
+#endif  // InkCollector_h__
diff --git a/widget/windows/TSFTextStore.cpp b/widget/windows/TSFTextStore.cpp
index 00c94d7233133..c6f88fc0cf733 100644
--- a/widget/windows/TSFTextStore.cpp
+++ b/widget/windows/TSFTextStore.cpp
@@ -2692,7 +2692,7 @@ TSFTextStore::QueryInsert(LONG acpTestStart, LONG acpTestEnd, ULONG cch,
 
   // XXX need to adjust to cluster boundary
   // Assume we are given good offsets for now
-  if (mComposition.isNothing() &&
+  if (IsWin8OrLater() && mComposition.isNothing() &&
       ((StaticPrefs::
             intl_tsf_hack_ms_traditional_chinese_query_insert_result() &&
         TSFStaticSink::IsMSChangJieOrMSQuickActive()) ||
@@ -3933,8 +3933,9 @@ bool TSFTextStore::ShouldSetInputScopeOfURLBarToDefault() {
     case TextInputProcessorID::eMicrosoftPinyinNewExperienceInputStyle:
     case TextInputProcessorID::eMicrosoftOldHangul:
     case TextInputProcessorID::eMicrosoftWubi:
-    case TextInputProcessorID::eMicrosoftIMEForKorean:
       return true;
+    case TextInputProcessorID::eMicrosoftIMEForKorean:
+      return IsWin8OrLater();
     default:
       return false;
   }
@@ -4859,7 +4860,8 @@ bool TSFTextStore::MaybeHackNoErrorLayoutBugs(LONG& aACPStart, LONG& aACPEnd) {
       }
       [[fallthrough]];
     case TextInputProcessorID::eMicrosoftChangJie:
-      if (!StaticPrefs::
+      if (!IsWin8OrLater() ||
+          !StaticPrefs::
               intl_tsf_hack_ms_traditional_chinese_do_not_return_no_layout_error()) {
         return false;
       }
@@ -4876,7 +4878,8 @@ bool TSFTextStore::MaybeHackNoErrorLayoutBugs(LONG& aACPStart, LONG& aACPEnd) {
     //      there is stateful cause or race in them.
     case TextInputProcessorID::eMicrosoftPinyin:
     case TextInputProcessorID::eMicrosoftWubi:
-      if (!StaticPrefs::
+      if (!IsWin8OrLater() ||
+          !StaticPrefs::
               intl_tsf_hack_ms_simplified_chinese_do_not_return_no_layout_error()) {
         return false;
       }
diff --git a/widget/windows/ToastNotification.cpp b/widget/windows/ToastNotification.cpp
index ea8ea99e418de..dbf4ee09e8bb0 100644
--- a/widget/windows/ToastNotification.cpp
+++ b/widget/windows/ToastNotification.cpp
@@ -24,6 +24,7 @@
 #include "mozilla/Logging.h"
 #include "mozilla/Services.h"
 #include "mozilla/WidgetUtils.h"
+#include "mozilla/WindowsVersion.h"
 #include "nsAppRunner.h"
 #include "nsComponentManagerUtils.h"
 #include "nsCOMPtr.h"
@@ -37,6 +38,7 @@
 #include "prenv.h"
 #include "ToastNotificationHandler.h"
 #include "ToastNotificationHeaderOnlyUtils.h"
+#include "WinTaskbar.h"
 
 namespace mozilla {
 namespace widget {
@@ -65,6 +67,10 @@ ToastNotification::ToastNotification() = default;
 ToastNotification::~ToastNotification() = default;
 
 nsresult ToastNotification::Init() {
+  if (!IsWin8OrLater()) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
   if (!PR_GetEnv("XPCSHELL_TEST_PROFILE_DIR")) {
     // Windows Toast Notification requires AppId.  But allow `xpcshell` to
     // create the service to test other functionality.
@@ -102,6 +108,18 @@ bool ToastNotification::EnsureAumidRegistered() {
     return true;
   }
 
+  // Fall back to start menu shortcut for Windows 8; toast AUMID registration in
+  // the registry only works in Windows 10+.
+  if (!IsWin10OrLater()) {
+    nsAutoString aumid;
+    if (!WinTaskbar::GetAppUserModelID(aumid)) {
+      return false;
+    }
+
+    mAumid = Some(aumid);
+    return true;
+  }
+
   nsAutoString installHash;
   nsresult rv = gDirServiceProvider->GetInstallHash(installHash);
   NS_ENSURE_SUCCESS(rv, false);
diff --git a/widget/windows/ToastNotificationHandler.cpp b/widget/windows/ToastNotificationHandler.cpp
index 5181a7c500f4a..b8df009fbc9bd 100644
--- a/widget/windows/ToastNotificationHandler.cpp
+++ b/widget/windows/ToastNotificationHandler.cpp
@@ -526,10 +526,9 @@ ComPtr<IXmlDocument> ToastNotificationHandler::CreateToastXmlDocument() {
   MOZ_LOG(sWASLog, LogLevel::Debug,
           ("launchArg: '%s'", NS_ConvertUTF16toUTF8(launchArg).get()));
 
-  // Use newer toast layout for system (chrome-privileged) toasts. This gains us
-  // UI elements such as new image placement options (default image placement is
-  // larger and inline) and buttons.
-  if (mIsSystemPrincipal) {
+  // On modern Windows (10+), use newer toast layout, which makes images larger,
+  // for system (chrome-privileged) toasts.
+  if (IsWin10OrLater() && mIsSystemPrincipal) {
     ComPtr<IXmlNodeList> bindingElements;
     hr = toastXml->GetElementsByTagName(HStringReference(L"binding").Get(),
                                         &bindingElements);
@@ -819,16 +818,19 @@ bool ToastNotificationHandler::CreateWindowsNotificationFromXml(
       &mFailedToken);
   NS_ENSURE_TRUE(SUCCEEDED(hr), false);
 
-  ComPtr<IToastNotification2> notification2;
-  hr = mNotification.As(&notification2);
-  NS_ENSURE_TRUE(SUCCEEDED(hr), false);
+  // `IToastNotification2` not supported on versions older than Windows 10.
+  if (IsWin10OrLater()) {
+    ComPtr<IToastNotification2> notification2;
+    hr = mNotification.As(&notification2);
+    NS_ENSURE_TRUE(SUCCEEDED(hr), false);
 
-  HString hTag;
-  hr = hTag.Set(mWindowsTag.get());
-  NS_ENSURE_TRUE(SUCCEEDED(hr), false);
+    HString hTag;
+    hr = hTag.Set(mWindowsTag.get());
+    NS_ENSURE_TRUE(SUCCEEDED(hr), false);
 
-  hr = notification2->put_Tag(hTag.Get());
-  NS_ENSURE_TRUE(SUCCEEDED(hr), false);
+    hr = notification2->put_Tag(hTag.Get());
+    NS_ENSURE_TRUE(SUCCEEDED(hr), false);
+  }
 
   ComPtr<IToastNotificationManagerStatics> toastNotificationManagerStatics =
       GetToastNotificationManagerStatics();
@@ -1027,20 +1029,24 @@ HRESULT
 ToastNotificationHandler::OnDismiss(
     const ComPtr<IToastNotification>& notification,
     const ComPtr<IToastDismissedEventArgs>& aArgs) {
-  ComPtr<IToastNotification2> notification2;
-  HRESULT hr = notification.As(&notification2);
-  NS_ENSURE_TRUE(SUCCEEDED(hr), E_FAIL);
-
-  HString tagHString;
-  hr = notification2->get_Tag(tagHString.GetAddressOf());
-  NS_ENSURE_TRUE(SUCCEEDED(hr), E_FAIL);
-
-  unsigned int len;
-  const wchar_t* tagPtr = tagHString.GetRawBuffer(&len);
-  nsAutoString tag(tagPtr, len);
-
-  if (FindNotificationByTag(tag, mAumid)) {
-    return S_OK;
+  // Multiple dismiss events only occur on Windows 10 and later, prior versions
+  // of Windows didn't include `IToastNotification2`.
+  if (IsWin10OrLater()) {
+    ComPtr<IToastNotification2> notification2;
+    HRESULT hr = notification.As(&notification2);
+    NS_ENSURE_TRUE(SUCCEEDED(hr), E_FAIL);
+
+    HString tagHString;
+    hr = notification2->get_Tag(tagHString.GetAddressOf());
+    NS_ENSURE_TRUE(SUCCEEDED(hr), E_FAIL);
+
+    unsigned int len;
+    const wchar_t* tagPtr = tagHString.GetRawBuffer(&len);
+    nsAutoString tag(tagPtr, len);
+
+    if (FindNotificationByTag(tag, mAumid)) {
+      return S_OK;
+    }
   }
 
   SendFinished();
diff --git a/widget/windows/WinHeaderOnlyUtils.h b/widget/windows/WinHeaderOnlyUtils.h
index 15861cc73b889..eb928ff6bb8cc 100644
--- a/widget/windows/WinHeaderOnlyUtils.h
+++ b/widget/windows/WinHeaderOnlyUtils.h
@@ -23,6 +23,7 @@
 #include "mozilla/Maybe.h"
 #include "mozilla/ResultVariant.h"
 #include "mozilla/UniquePtr.h"
+#include "mozilla/WindowsVersion.h"
 #include "nsWindowsHelpers.h"
 
 #if defined(MOZILLA_INTERNAL_API)
@@ -511,13 +512,15 @@ class FileUniqueId final {
  private:
   void GetId(const nsAutoHandle& aFile) {
     FILE_ID_INFO fileIdInfo = {};
-    if (::GetFileInformationByHandleEx(aFile.get(), FileIdInfo, &fileIdInfo,
-                                       sizeof(fileIdInfo))) {
-      mId = fileIdInfo;
-      return;
+    if (IsWin8OrLater()) {
+      if (::GetFileInformationByHandleEx(aFile.get(), FileIdInfo, &fileIdInfo,
+                                         sizeof(fileIdInfo))) {
+        mId = fileIdInfo;
+        return;
+      }
+      // Only NTFS and ReFS support FileIdInfo. So we have to fallback if
+      // GetFileInformationByHandleEx failed.
     }
-    // Only NTFS and ReFS support FileIdInfo. So we have to fallback if
-    // GetFileInformationByHandleEx failed.
 
     BY_HANDLE_FILE_INFORMATION info = {};
     if (!::GetFileInformationByHandle(aFile.get(), &info)) {
@@ -738,6 +741,10 @@ inline LauncherResult<TOKEN_ELEVATION_TYPE> GetElevationType(
 }
 
 inline bool HasPackageIdentity() {
+  if (!IsWin8OrLater()) {
+    return false;
+  }
+
   HMODULE kernel32Dll = ::GetModuleHandleW(L"kernel32");
   if (!kernel32Dll) {
     return false;
diff --git a/widget/windows/WinIMEHandler.cpp b/widget/windows/WinIMEHandler.cpp
index 1313b1eed252c..23380de1ec5d1 100644
--- a/widget/windows/WinIMEHandler.cpp
+++ b/widget/windows/WinIMEHandler.cpp
@@ -718,7 +718,7 @@ bool IMEHandler::IsOnScreenKeyboardSupported() {
     return true;
   }
 #endif  // NIGHTLY_BUILD
-  if (!Preferences::GetBool(kOskEnabled, true) ||
+  if (!IsWin8OrLater() || !Preferences::GetBool(kOskEnabled, true) ||
       !IMEHandler::NeedOnScreenKeyboard()) {
     return false;
   }
@@ -756,6 +756,10 @@ void IMEHandler::MaybeDismissOnScreenKeyboard(nsWindow* aWindow, Sync aSync) {
     OSKVRManager::DismissOnScreenKeyboard();
   }
 #endif  // NIGHTLY_BUILD
+  if (!IsWin8OrLater()) {
+    return;
+  }
+
   if (aSync == Sync::Yes) {
     DismissOnScreenKeyboard(aWindow);
     return;
@@ -794,6 +798,12 @@ bool IMEHandler::WStringStartsWithCaseInsensitive(const std::wstring& aHaystack,
 // an on-screen keyboard for text input.
 // static
 bool IMEHandler::NeedOnScreenKeyboard() {
+  // This function is only supported for Windows 8 and up.
+  if (!IsWin8OrLater()) {
+    Preferences::SetString(kOskDebugReason, L"IKPOS: Requires Win8+.");
+    return false;
+  }
+
   if (!Preferences::GetBool(kOskDetectPhysicalKeyboard, true)) {
     Preferences::SetString(kOskDebugReason, L"IKPOS: Detection disabled.");
     return true;
diff --git a/widget/windows/WinPointerEvents.cpp b/widget/windows/WinPointerEvents.cpp
index 57e19a0c4b01d..c0465da7d7962 100644
--- a/widget/windows/WinPointerEvents.cpp
+++ b/widget/windows/WinPointerEvents.cpp
@@ -13,6 +13,7 @@
 #include "WinUtils.h"
 #include "mozilla/MouseEvents.h"
 #include "mozilla/StaticPrefs_dom.h"
+#include "mozilla/WindowsVersion.h"
 #include "mozilla/dom/MouseEventBinding.h"
 
 using namespace mozilla;
@@ -30,6 +31,10 @@ WinPointerEvents::WinPointerEvents() { InitLibrary(); }
 /* Load and shutdown */
 void WinPointerEvents::InitLibrary() {
   MOZ_ASSERT(XRE_IsParentProcess());
+  if (!IsWin8OrLater()) {
+    // Only Win8 or later supports WM_POINTER*
+    return;
+  }
   if (getPointerType) {
     // Return if we already initialized the PointerEvent related interfaces
     return;
@@ -105,6 +110,12 @@ bool WinPointerEvents::GetPointerPenInfo(uint32_t aPointerId,
   return getPointerPenInfo(aPointerId, aPenInfo);
 }
 
+bool WinPointerEvents::ShouldEnableInkCollector() {
+  // We need InkCollector on Win7. For Win8 or later, we handle WM_POINTER* for
+  // pen.
+  return !IsWin8OrLater();
+}
+
 bool WinPointerEvents::ShouldRollupOnPointerEvent(UINT aMsg, WPARAM aWParam) {
   MOZ_ASSERT(aMsg == WM_POINTERDOWN);
   // Only roll up popups when we handling WM_POINTER* to fire Gecko
diff --git a/widget/windows/WinPointerEvents.h b/widget/windows/WinPointerEvents.h
index 94179e7b4e1cb..c10b9ce197266 100644
--- a/widget/windows/WinPointerEvents.h
+++ b/widget/windows/WinPointerEvents.h
@@ -44,6 +44,7 @@ class WinPointerEvents final {
   POINTER_INPUT_TYPE GetPointerType(uint32_t aPointerId);
   bool GetPointerInfo(uint32_t aPointerId, POINTER_INFO* aPointerInfo);
   bool GetPointerPenInfo(uint32_t aPointerId, POINTER_PEN_INFO* aPenInfo);
+  bool ShouldEnableInkCollector();
   bool ShouldRollupOnPointerEvent(UINT aMsg, WPARAM aWParam);
   bool ShouldFirePointerEventByWinPointerMessages();
   WinPointerInfo* GetCachedPointerInfo(UINT aMsg, WPARAM aWParam);
diff --git a/widget/windows/WinUtils.cpp b/widget/windows/WinUtils.cpp
index 70038c60ee9bc..dc1a41444f8a7 100644
--- a/widget/windows/WinUtils.cpp
+++ b/widget/windows/WinUtils.cpp
@@ -28,6 +28,7 @@
 #include "mozilla/RefPtr.h"
 #include "mozilla/SchedulerGroup.h"
 #include "mozilla/WinHeaderOnlyUtils.h"
+#include "mozilla/WindowsVersion.h"
 #include "mozilla/Unused.h"
 #include "nsIContentPolicy.h"
 #include "WindowsUIUtils.h"
@@ -99,7 +100,7 @@ void WinUtils::Initialize() {
   // Dpi-Awareness is not supported with Win32k Lockdown enabled, so we don't
   // initialize DPI-related members and assert later that nothing accidently
   // uses these static members
-  if (!IsWin32kLockedDown()) {
+  if (IsWin10OrLater() && !IsWin32kLockedDown()) {
     HMODULE user32Dll = ::GetModuleHandleW(L"user32");
     if (user32Dll) {
       auto getThreadDpiAwarenessContext =
@@ -128,7 +129,9 @@ void WinUtils::Initialize() {
     }
   }
 
-  sHasPackageIdentity = mozilla::HasPackageIdentity();
+  if (IsWin8OrLater()) {
+    sHasPackageIdentity = mozilla::HasPackageIdentity();
+  }
 }
 
 // static
@@ -1605,6 +1608,10 @@ static bool IsTabletDevice() {
   // - It is used as a tablet which means that it has no keyboard connected.
   // On Windows 10 it means that it is verifying with ConvertibleSlateMode.
 
+  if (!IsWin8OrLater()) {
+    return false;
+  }
+
   if (WindowsUIUtils::GetInTabletMode()) {
     return true;
   }
@@ -2152,6 +2159,10 @@ static LONG SetRelativeScaleStep(LUID aAdapterId, int32_t aRelativeScaleStep) {
 }
 
 nsresult WinUtils::SetHiDPIMode(bool aHiDPI) {
+  if (!IsWin10OrLater()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
   auto config = GetDisplayConfig();
   if (!config) {
     return NS_ERROR_NOT_AVAILABLE;
@@ -2207,6 +2218,10 @@ nsresult WinUtils::SetHiDPIMode(bool aHiDPI) {
 }
 
 nsresult WinUtils::RestoreHiDPIMode() {
+  if (!IsWin10OrLater()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
   if (sCurRelativeScaleStep == std::numeric_limits<int>::max()) {
     // The DPI setting hasn't been changed.
     return NS_ERROR_UNEXPECTED;
diff --git a/widget/windows/WinWindowOcclusionTracker.cpp b/widget/windows/WinWindowOcclusionTracker.cpp
index a38f9505856e7..9040441c4b5e4 100644
--- a/widget/windows/WinWindowOcclusionTracker.cpp
+++ b/widget/windows/WinWindowOcclusionTracker.cpp
@@ -881,6 +881,10 @@ void WinWindowOcclusionTracker::WindowOcclusionCalculator::Initialize() {
   CALC_LOG(LogLevel::Info, "Initialize()");
 
 #ifndef __MINGW32__
+  if (!IsWin10OrLater()) {
+    return;
+  }
+
   RefPtr<IVirtualDesktopManager> desktopManager;
   HRESULT hr = ::CoCreateInstance(
       CLSID_VirtualDesktopManager, NULL, CLSCTX_INPROC_SERVER,
diff --git a/widget/windows/WindowsSMTCProvider.cpp b/widget/windows/WindowsSMTCProvider.cpp
index 8cce5612def6c..eee7e419ae574 100644
--- a/widget/windows/WindowsSMTCProvider.cpp
+++ b/widget/windows/WindowsSMTCProvider.cpp
@@ -19,6 +19,7 @@
 #  include "mozilla/Logging.h"
 #  include "mozilla/Maybe.h"
 #  include "mozilla/WidgetUtils.h"
+#  include "mozilla/WindowsVersion.h"
 #  include "mozilla/ScopeExit.h"
 #  include "mozilla/dom/MediaControlUtils.h"
 #  include "mozilla/media/MediaUtils.h"
@@ -136,6 +137,11 @@ bool WindowsSMTCProvider::Open() {
   LOG("Opening Source");
   MOZ_ASSERT(!mInitialized);
 
+  if (!IsWin8Point1OrLater()) {
+    LOG("Windows 8.1 or later is required for Media Key Support");
+    return false;
+  }
+
   if (!InitDisplayAndControls()) {
     LOG("Failed to initialize the SMTC and its display");
     return false;
diff --git a/widget/windows/WindowsUIUtils.cpp b/widget/windows/WindowsUIUtils.cpp
index 10f0bb8306f67..bf8a6c7dff63c 100644
--- a/widget/windows/WindowsUIUtils.cpp
+++ b/widget/windows/WindowsUIUtils.cpp
@@ -303,6 +303,11 @@ static IInspectable* GetUISettings() {
   // expected, sigh.
   static StaticRefPtr<IInspectable> sUiSettingsAsInspectable;
 
+  if (!IsWin10OrLater()) {
+    // Windows.UI.ViewManagement.UISettings is Win10+ only.
+    return nullptr;
+  }
+
   if (!sUiSettingsAsInspectable) {
     ComPtr<IInspectable> uiSettingsAsInspectable;
     ::RoActivateInstance(
@@ -545,6 +550,10 @@ bool WindowsUIUtils::ComputeTransparencyEffects() {
 
 void WindowsUIUtils::UpdateInTabletMode() {
 #ifndef __MINGW32__
+  if (!IsWin10OrLater()) {
+    return;
+  }
+
   nsresult rv;
   nsCOMPtr<nsIWindowMediator> winMediator(
       do_GetService(NS_WINDOWMEDIATOR_CONTRACTID, &rv));
@@ -624,6 +633,10 @@ Result<HStringUniquePtr, HRESULT> ConvertToWindowsString(
 
 static Result<Ok, nsresult> RequestShare(
     const std::function<HRESULT(IDataRequestedEventArgs* pArgs)>& aCallback) {
+  if (!IsWin10OrLater()) {
+    return Err(NS_ERROR_FAILURE);
+  }
+
   HWND hwnd = GetForegroundWindow();
   if (!hwnd) {
     return Err(NS_ERROR_FAILURE);
diff --git a/widget/windows/docs/blocklist.rst b/widget/windows/docs/blocklist.rst
index 5450faaa1b68a..1b7a1a67642d4 100644
--- a/widget/windows/docs/blocklist.rst
+++ b/widget/windows/docs/blocklist.rst
@@ -123,6 +123,8 @@ Parameters
 |           |   - A tuple consisting of four digits                                          |
 |           |   - A 32-bit integer representing a Unix timestamp with PETimeStamp            |
 +-----------+--------------------------------------------------------------------------------+
+| Flags     | BLOCK_WIN8_AND_OLDER \| BLOCK_WIN7_AND_OLDER                                   |
++-----------+--------------------------------------------------------------------------------+
 
 Variable
 ********
@@ -173,6 +175,15 @@ To specify a version, you can use either of the following formats:
 - | A 32-bit integer representing a Unix timestamp with PETimeStamp. This is compared to an integer of IMAGE_FILE_HEADER::TimeDateStamp.
   | Example: PETimeStamp(0x12345678)
 
+Flags
+*****
+
+If you know a problem happens only on older Windows versions, you can use one of
+the following flags to narrow down the affected platform.
+
+- BLOCK_WIN8_AND_OLDER
+- BLOCK_WIN7_AND_OLDER
+
 
 -----------------
 Technical details
diff --git a/widget/windows/moz.build b/widget/windows/moz.build
index 3415d4153fd0a..6f0cc689b404b 100644
--- a/widget/windows/moz.build
+++ b/widget/windows/moz.build
@@ -74,6 +74,7 @@ UNIFIED_SOURCES += [
     "GfxInfo.cpp",
     "IEnumFE.cpp",
     "IMMHandler.cpp",
+    "InkCollector.cpp",
     "JumpListBuilder.cpp",
     "KeyboardLayout.cpp",
     "LSPAnnotator.cpp",
diff --git a/widget/windows/nsAppShell.cpp b/widget/windows/nsAppShell.cpp
index bdc24bcace6bb..bc7d462766141 100644
--- a/widget/windows/nsAppShell.cpp
+++ b/widget/windows/nsAppShell.cpp
@@ -34,6 +34,7 @@
 #include "mozilla/NativeNt.h"
 #include "mozilla/WindowsDiagnostics.h"
 #include "mozilla/WindowsProcessMitigations.h"
+#include "mozilla/WindowsVersion.h"
 
 #include <winternl.h>
 
@@ -217,13 +218,66 @@ class WinWakeLockListener final : public nsIDOMMozWakeLockListener {
   HANDLE mNonDisplayHandle = nullptr;
 };
 NS_IMPL_ISUPPORTS(WinWakeLockListener, nsIDOMMozWakeLockListener)
+
+// This wakelock is used for the version older than Windows7.
+class LegacyWinWakeLockListener final : public nsIDOMMozWakeLockListener {
+ public:
+  NS_DECL_ISUPPORTS
+  LegacyWinWakeLockListener() { MOZ_ASSERT(XRE_IsParentProcess()); }
+
+ private:
+  ~LegacyWinWakeLockListener() {}
+
+  NS_IMETHOD Callback(const nsAString& aTopic,
+                      const nsAString& aState) override {
+    WAKE_LOCK_LOG("WinWakeLock: topic=%s, state=%s",
+                  NS_ConvertUTF16toUTF8(aTopic).get(),
+                  NS_ConvertUTF16toUTF8(aState).get());
+    if (!aTopic.EqualsASCII("screen") && !aTopic.EqualsASCII("audio-playing") &&
+        !aTopic.EqualsASCII("video-playing")) {
+      return NS_OK;
+    }
+
+    // Check what kind of lock we will require, if both display lock and non
+    // display lock are needed, we would require display lock because it has
+    // higher priority.
+    if (aTopic.EqualsASCII("audio-playing")) {
+      mRequireForNonDisplayLock = aState.EqualsASCII("locked-foreground") ||
+                                  aState.EqualsASCII("locked-background");
+    } else if (aTopic.EqualsASCII("screen") ||
+               aTopic.EqualsASCII("video-playing")) {
+      mRequireForDisplayLock = aState.EqualsASCII("locked-foreground");
+    }
+
+    if (mRequireForDisplayLock) {
+      WAKE_LOCK_LOG("WinWakeLock: Request display lock");
+      SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS);
+    } else if (mRequireForNonDisplayLock) {
+      WAKE_LOCK_LOG("WinWakeLock: Request non-display lock");
+      SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS);
+    } else {
+      WAKE_LOCK_LOG("WinWakeLock: reset lock");
+      SetThreadExecutionState(ES_CONTINUOUS);
+    }
+    return NS_OK;
+  }
+
+  bool mRequireForDisplayLock = false;
+  bool mRequireForNonDisplayLock = false;
+};
+
+NS_IMPL_ISUPPORTS(LegacyWinWakeLockListener, nsIDOMMozWakeLockListener)
 StaticRefPtr<nsIDOMMozWakeLockListener> sWakeLockListener;
 
 static void AddScreenWakeLockListener() {
   nsCOMPtr<nsIPowerManagerService> sPowerManagerService =
       do_GetService(POWERMANAGERSERVICE_CONTRACTID);
   if (sPowerManagerService) {
-    sWakeLockListener = new WinWakeLockListener();
+    if (IsWin7SP1OrLater()) {
+      sWakeLockListener = new WinWakeLockListener();
+    } else {
+      sWakeLockListener = new LegacyWinWakeLockListener();
+    }
     sPowerManagerService->AddWakeLockListener(sWakeLockListener);
   } else {
     NS_WARNING(
diff --git a/widget/windows/nsNativeThemeWin.cpp b/widget/windows/nsNativeThemeWin.cpp
index 1cbad3777c9bc..9c58e37ff973d 100644
--- a/widget/windows/nsNativeThemeWin.cpp
+++ b/widget/windows/nsNativeThemeWin.cpp
@@ -19,6 +19,7 @@
 #include "mozilla/RelativeLuminanceUtils.h"
 #include "mozilla/StaticPrefs_layout.h"
 #include "mozilla/StaticPrefs_widget.h"
+#include "mozilla/WindowsVersion.h"
 #include "mozilla/dom/XULButtonElement.h"
 #include "nsColor.h"
 #include "nsComboboxControlFrame.h"
@@ -791,8 +792,8 @@ nsresult nsNativeThemeWin::GetThemePartAndState(nsIFrame* aFrame,
 
 static bool AssumeThemePartAndStateAreTransparent(int32_t aPart,
                                                   int32_t aState) {
-  if (!nsUXThemeData::IsHighContrastOn() && aPart == MENU_POPUPITEM &&
-      aState == MBI_NORMAL) {
+  if (!(IsWin8Point1OrLater() && nsUXThemeData::IsHighContrastOn()) &&
+      aPart == MENU_POPUPITEM && aState == MBI_NORMAL) {
     return true;
   }
   return false;
diff --git a/widget/windows/nsWindow.cpp b/widget/windows/nsWindow.cpp
index 268e63a0f6424..1554e72e9c5e6 100644
--- a/widget/windows/nsWindow.cpp
+++ b/widget/windows/nsWindow.cpp
@@ -206,6 +206,8 @@
 
 #include <d3d11.h>
 
+#include "InkCollector.h"
+
 // ERROR from wingdi.h (below) gets undefined by some code.
 // #define ERROR               0
 // #define RGN_ERROR ERROR
@@ -354,7 +356,8 @@ static void RegisterWindowClass(const wchar_t* aClassName, UINT aExtraStyle,
 // Global event hook for window cloaking. Never deregistered.
 //  - `Nothing` if not yet set.
 //  - `Some(nullptr)` if no attempt should be made to set it.
-static mozilla::Maybe<HWINEVENTHOOK> sWinCloakEventHook = Nothing();
+static mozilla::Maybe<HWINEVENTHOOK> sWinCloakEventHook =
+    IsWin8OrLater() ? Nothing() : Some(HWINEVENTHOOK(nullptr));
 static mozilla::LazyLogModule sCloakingLog("DWMCloaking");
 
 namespace mozilla {
@@ -473,6 +476,10 @@ class TIPMessageHandler {
   }
 
   static void Initialize() {
+    if (!IsWin8OrLater()) {
+      return;
+    }
+
     if (sInstance) {
       return;
     }
@@ -506,6 +513,16 @@ class TIPMessageHandler {
                                ::GetCurrentThreadId());
     MOZ_ASSERT(mHook);
 
+    // On touchscreen devices, tiptsf.dll will have been loaded when STA COM was
+    // first initialized.
+    if (!IsWin10OrLater() && GetModuleHandle(L"tiptsf.dll") &&
+        !sProcessCaretEventsStub) {
+      sTipTsfInterceptor.Init("tiptsf.dll");
+      DebugOnly<bool> ok = sProcessCaretEventsStub.Set(
+          sTipTsfInterceptor, "ProcessCaretEvents", &ProcessCaretEventsHook);
+      MOZ_ASSERT(ok);
+    }
+
     if (!sSendMessageTimeoutWStub) {
       sUser32Intercept.Init("user32.dll");
       DebugOnly<bool> hooked = sSendMessageTimeoutWStub.Set(
@@ -552,6 +569,16 @@ class TIPMessageHandler {
     return ::CallNextHookEx(nullptr, aCode, aWParam, aLParam);
   }
 
+  static void CALLBACK ProcessCaretEventsHook(HWINEVENTHOOK aWinEventHook,
+                                              DWORD aEvent, HWND aHwnd,
+                                              LONG aObjectId, LONG aChildId,
+                                              DWORD aGeneratingTid,
+                                              DWORD aEventTime) {
+    A11yInstantiationBlocker block;
+    sProcessCaretEventsStub(aWinEventHook, aEvent, aHwnd, aObjectId, aChildId,
+                            aGeneratingTid, aEventTime);
+  }
+
   static LRESULT WINAPI SendMessageTimeoutWHook(HWND aHwnd, UINT aMsgCode,
                                                 WPARAM aWParam, LPARAM aLParam,
                                                 UINT aFlags, UINT aTimeout,
@@ -575,6 +602,9 @@ class TIPMessageHandler {
     return static_cast<LRESULT>(TRUE);
   }
 
+  static WindowsDllInterceptor sTipTsfInterceptor;
+  static WindowsDllInterceptor::FuncHookType<WINEVENTPROC>
+      sProcessCaretEventsStub;
   static WindowsDllInterceptor::FuncHookType<decltype(&SendMessageTimeoutW)>
       sSendMessageTimeoutWStub;
   static StaticAutoPtr<TIPMessageHandler> sInstance;
@@ -584,6 +614,9 @@ class TIPMessageHandler {
   uint32_t mA11yBlockCount;
 };
 
+WindowsDllInterceptor TIPMessageHandler::sTipTsfInterceptor;
+WindowsDllInterceptor::FuncHookType<WINEVENTPROC>
+    TIPMessageHandler::sProcessCaretEventsStub;
 WindowsDllInterceptor::FuncHookType<decltype(&SendMessageTimeoutW)>
     TIPMessageHandler::sSendMessageTimeoutWStub;
 StaticAutoPtr<TIPMessageHandler> TIPMessageHandler::sInstance;
@@ -615,6 +648,10 @@ class InitializeVirtualDesktopManagerTask : public Task {
 #endif
 
   virtual TaskResult Run() override {
+    if (!IsWin10OrLater()) {
+      return TaskResult::Complete;
+    }
+
     RefPtr<IVirtualDesktopManager> desktopManager;
     HRESULT hr = ::CoCreateInstance(
         CLSID_VirtualDesktopManager, NULL, CLSCTX_INPROC_SERVER,
@@ -701,6 +738,9 @@ nsWindow::nsWindow(bool aIsChildWindow)
     // Init theme data
     nsUXThemeData::UpdateNativeThemeInfo();
     RedirectedKeyDownMessageManager::Forget();
+    if (mPointerEvents.ShouldEnableInkCollector()) {
+      InkCollector::sInkCollector = new InkCollector();
+    }
   }  // !sInstanceCount
 
   sInstanceCount++;
@@ -725,6 +765,10 @@ nsWindow::~nsWindow() {
 
   // Global shutdown
   if (sInstanceCount == 0) {
+    if (InkCollector::sInkCollector) {
+      InkCollector::sInkCollector->Shutdown();
+      InkCollector::sInkCollector = nullptr;
+    }
     IMEHandler::Terminate();
     sCurrentCursor = {};
     if (sIsOleInitialized) {
@@ -812,6 +856,13 @@ void nsWindow::RecreateDirectManipulationIfNeeded() {
     return;
   }
 
+  if (!IsWin10OrLater()) {
+    // Chrome source said the Windows Direct Manipulation implementation had
+    // important bugs until Windows 10 (although IE on Windows 8.1 seems to use
+    // Direct Manipulation).
+    return;
+  }
+
   mDmOwner = MakeUnique<DirectManipulationOwner>(this);
 
   LayoutDeviceIntRect bounds(mBounds.X(), mBounds.Y(), mBounds.Width(),
@@ -880,10 +931,24 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
   DWORD style = WindowStyle();
   DWORD extendedStyle = WindowExStyle();
 
+  // When window is PiP window on Windows7, WS_EX_COMPOSITED is set to suppress
+  // flickering during resizing with hardware acceleration.
+  bool isPIPWindow = aInitData && aInitData->mPIPWindow;
+  if (isPIPWindow && !IsWin8OrLater() &&
+      gfxConfig::IsEnabled(gfx::Feature::HW_COMPOSITING) &&
+      WidgetTypeSupportsAcceleration()) {
+    extendedStyle |= WS_EX_COMPOSITED;
+  }
+
   if (mWindowType == WindowType::Popup) {
     if (!aParent) {
       parent = nullptr;
     }
+
+    if (!IsWin8OrLater() && HasBogusPopupsDropShadowOnMultiMonitor() &&
+        ShouldUseOffMainThreadCompositing()) {
+      extendedStyle |= WS_EX_COMPOSITED;
+    }
   } else if (mWindowType == WindowType::Invisible) {
     // Make sure CreateWindowEx succeeds at creating a toplevel window
     style &= ~0x40000000;  // WS_CHILDWINDOW
@@ -2570,6 +2635,9 @@ void nsWindow::ResetLayout() {
 #define DWMWA_USE_IMMERSIVE_DARK_MODE 20
 
 void nsWindow::UpdateDarkModeToolbar() {
+  if (!IsWin10OrLater()) {
+    return;
+  }
   PreferenceSheet::EnsureInitialized();
   BOOL dark = PreferenceSheet::ColorSchemeForChrome() == ColorScheme::Dark;
   DwmSetWindowAttribute(mWnd, DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1, &dark,
@@ -2749,12 +2817,14 @@ bool nsWindow::UpdateNonClientMargins(bool aReflowWindow) {
         mNonClientOffset.bottom -= kHiddenTaskbarSize;
       }
 
-      // When we are drawing the non-client region, we need
+      // On Windows 10+, when we are drawing the non-client region, we need
       // to clear the portion of the NC region that is exposed by the
       // hidden taskbar.  As above, we clear the bottom of the NC region
       // when the taskbar is at the top of the screen.
-      UINT clearEdge = (edge == ABE_TOP) ? ABE_BOTTOM : edge;
-      mClearNCEdge = Some(clearEdge);
+      if (IsWin10OrLater()) {
+        UINT clearEdge = (edge == ABE_TOP) ? ABE_BOTTOM : edge;
+        mClearNCEdge = Some(clearEdge);
+      }
     }
   } else {
     mNonClientOffset = NormalWindowNonClientOffset();
@@ -4317,6 +4387,17 @@ bool nsWindow::DispatchMouseEvent(EventMessage aEventMessage, WPARAM wParam,
   uint32_t pointerId =
       aPointerInfo ? aPointerInfo->pointerId : MOUSE_POINTERID();
 
+  // Since it is unclear whether a user will use the digitizer,
+  // Postpone initialization until first PEN message will be found.
+  if (MouseEvent_Binding::MOZ_SOURCE_PEN == aInputSource
+      // Messages should be only at topLevel window.
+      && WindowType::TopLevel == mWindowType
+      // Currently this scheme is used only when pointer events is enabled.
+      && InkCollector::sInkCollector) {
+    InkCollector::sInkCollector->SetTarget(mWnd);
+    InkCollector::sInkCollector->SetPointerId(pointerId);
+  }
+
   switch (aEventMessage) {
     case eMouseDown:
       CaptureMouse(true);
@@ -5518,6 +5599,21 @@ bool nsWindow::ProcessMessageInternal(UINT msg, WPARAM& wParam, LPARAM& lParam,
                          MouseButton::ePrimary, MOUSE_INPUT_SOURCE());
     } break;
 
+    case MOZ_WM_PEN_LEAVES_HOVER_OF_DIGITIZER: {
+      LPARAM pos = lParamToClient(::GetMessagePos());
+      MOZ_ASSERT(InkCollector::sInkCollector);
+      uint16_t pointerId = InkCollector::sInkCollector->GetPointerId();
+      if (pointerId != 0) {
+        WinPointerInfo pointerInfo;
+        pointerInfo.pointerId = pointerId;
+        DispatchMouseEvent(eMouseExitFromWidget, wParam, pos, false,
+                           MouseButton::ePrimary,
+                           MouseEvent_Binding::MOZ_SOURCE_PEN, &pointerInfo);
+        InkCollector::sInkCollector->ClearTarget();
+        InkCollector::sInkCollector->ClearPointerId();
+      }
+    } break;
+
     case WM_CONTEXTMENU: {
       // If the context menu is brought up by a touch long-press, then
       // the APZ code is responsible for dealing with this, so we don't
@@ -7384,6 +7480,7 @@ void nsWindow::OnDPIChanged(int32_t x, int32_t y, int32_t width,
 /* static */
 void nsWindow::OnCloakEvent(HWND aWnd, bool aCloaked) {
   MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(IsWin8OrLater());
 
   const char* const kEventName = aCloaked ? "CLOAKED" : "UNCLOAKED";
   nsWindow* pWin = WinUtils::GetNSWindowPtr(aWnd);
@@ -8914,6 +9011,25 @@ nsresult nsWindow::RestoreHiDPIMode() { return WinUtils::RestoreHiDPIMode(); }
 mozilla::Maybe<UINT> nsWindow::GetHiddenTaskbarEdge() {
   HMONITOR windowMonitor = ::MonitorFromWindow(mWnd, MONITOR_DEFAULTTONEAREST);
 
+  if (!IsWin8OrLater()) {
+    // Per-monitor taskbar information is not available.
+    APPBARDATA appBarData;
+    appBarData.cbSize = sizeof(appBarData);
+    UINT taskbarState = SHAppBarMessage(ABM_GETSTATE, &appBarData);
+    if (ABS_AUTOHIDE & taskbarState) {
+      appBarData.hWnd = FindWindow(L"Shell_TrayWnd", nullptr);
+      if (appBarData.hWnd) {
+        HMONITOR taskbarMonitor =
+            ::MonitorFromWindow(appBarData.hWnd, MONITOR_DEFAULTTOPRIMARY);
+        if (taskbarMonitor == windowMonitor) {
+          SHAppBarMessage(ABM_GETTASKBARPOS, &appBarData);
+          return Some(appBarData.uEdge);
+        }
+      }
+    }
+    return Nothing();
+  }
+
   // Check all four sides of our monitor for an appbar.  Skip any that aren't
   // the system taskbar.
   MONITORINFO mi;
diff --git a/widget/windows/nsWindowTaskbarConcealer.cpp b/widget/windows/nsWindowTaskbarConcealer.cpp
index b2b6b13a1dba7..24358a433eeb2 100644
--- a/widget/windows/nsWindowTaskbarConcealer.cpp
+++ b/widget/windows/nsWindowTaskbarConcealer.cpp
@@ -10,6 +10,7 @@
 
 #include "mozilla/Logging.h"
 #include "mozilla/StaticPrefs_widget.h"
+#include "mozilla/WindowsVersion.h"
 #include "WinUtils.h"
 
 using namespace mozilla;
@@ -252,6 +253,69 @@ void nsWindow::TaskbarConcealer::UpdateAllState(
 // Mark this window as requesting to occlude the taskbar. (The caller is
 // responsible for keeping any local state up-to-date.)
 void TaskbarConcealerImpl::MarkAsHidingTaskbar(HWND aWnd, bool aMark) {
+  // USE OF UNDOCUMENTED BEHAVIOR:
+  //
+  // `MarkFullscreenWindow` is documented not to be sufficient. It will indeed
+  // cause a window to be treated as fullscreen; but, in its absence, Windows
+  // will also use explicitly undocumented heuristics to determine whether or
+  // not to treat a given window as full-screen.
+  //
+  // In Windows 8.1 and later, these heuristics don't seem to apply to us.
+  // However, in Windows 7, they do -- they determine that our fullscreen
+  // windows are, indeed, fullscreen. (That this is technically correct is of
+  // little importance, given that Windows then goes on to do the wrong thing
+  // with that knowledge.)
+  //
+  // Fortunately, `MarkFullscreenWindow` does have a converse: the `NonRudeHWND`
+  // window property. A window with this property set will not be treated as
+  // fullscreen.
+  //
+  // ===
+  //
+  // DIFFERENCE FROM DOCUMENTED BEHAVIOR:
+  //
+  // The documentation, as it was at the time of writing, is archived at:
+  // https://web.archive.org/web/20211223073250/https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist2-markfullscreenwindow
+  //
+  // The most relevant paragraph follows:
+  //
+  // > **Since Windows 7**, call `SetProp(hwnd, L”NonRudeHWND”,
+  // > reinterpret_cast<HANDLE>(TRUE))` before showing a window to indicate to
+  // > the Shell that the window should not be treated as full-screen.
+  //
+  // The key words in that paragraph are "before showing a window". On Windows 7
+  // this has no particular effect, but it completely changes the behavior on
+  // Windows 8.1 and Windows 10 -- if `NonRudeHWND` is set on a window before it
+  // is shown, that window will not be treated as fullscreen **even if the
+  // property is later removed!**
+  //
+  // `NonRudeHWND` isn't actually documented to do anything at all if it's set
+  // after the window has already been shown. That it seems to do exactly what
+  // we need on Windows 7 -- prevent a window from being detected as fullscreen
+  // while it's set, and only then -- is a stroke of fortune.
+
+  static const bool kUseWin7MarkingHack = [&] {
+    switch (StaticPrefs::widget_windows_fullscreen_marking_workaround()) {
+      case -1:
+        return false;
+      case 1:
+        return true;
+      default:
+        // The behavior on Windows 8 is not known. Hopefully there are no
+        // side effects there.
+        return !mozilla::IsWin8Point1OrLater();
+    }
+  }();
+
+  if (kUseWin7MarkingHack) {
+    constexpr static LPCWSTR kPropName = L"NonRudeHWND";
+    if (aMark) {
+      ::RemovePropW(aWnd, kPropName);
+    } else {
+      ::SetPropW(aWnd, kPropName, reinterpret_cast<HANDLE>(TRUE));
+    }
+  }
+
   const char* const sMark = aMark ? "true" : "false";
 
   if (!mTaskbarInfo) {
