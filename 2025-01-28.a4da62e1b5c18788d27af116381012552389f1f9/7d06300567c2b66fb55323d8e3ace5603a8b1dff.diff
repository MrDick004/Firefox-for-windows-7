diff --git a/dom/canvas/CanvasRenderingContext2D.cpp b/dom/canvas/CanvasRenderingContext2D.cpp
index 04486ffbdd5e..53defd2722a2 100644
--- a/dom/canvas/CanvasRenderingContext2D.cpp
+++ b/dom/canvas/CanvasRenderingContext2D.cpp
@@ -5462,7 +5462,7 @@ MaybeGetSurfaceDescriptorForRemoteCanvas(
       // FileHandleWrapper::mHandle is not possible simply by using shmen. When
       // it is tried, parent side process just causes crash during destroying
       // FileHandleWrapper.
-      descD3D10.handle() = nullptr;
+      descD3D10.handle() = 0;
       return sd;
     }
   }
diff --git a/dom/webgpu/ExternalTextureD3D11.cpp b/dom/webgpu/ExternalTextureD3D11.cpp
index aa01bc41eb9d..e8e7533ba557 100644
--- a/dom/webgpu/ExternalTextureD3D11.cpp
+++ b/dom/webgpu/ExternalTextureD3D11.cpp
@@ -38,8 +38,7 @@ UniquePtr<ExternalTextureD3D11> ExternalTextureD3D11::Create(
     desc.BindFlags |= D3D11_BIND_UNORDERED_ACCESS;
   }
 
-  desc.MiscFlags =
-      D3D11_RESOURCE_MISC_SHARED_NTHANDLE | D3D11_RESOURCE_MISC_SHARED;
+  desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED;
 
   RefPtr<ID3D11Texture2D> texture;
   HRESULT hr =
@@ -48,56 +47,42 @@ UniquePtr<ExternalTextureD3D11> ExternalTextureD3D11::Create(
     gfxCriticalNoteOnce << "CreateTexture2D failed:  " << gfx::hexa(hr);
     return nullptr;
   }
-
-  RefPtr<IDXGIResource1> resource;
-  texture->QueryInterface((IDXGIResource1**)getter_AddRefs(resource));
-  if (!resource) {
-    gfxCriticalNoteOnce << "Failed to get IDXGIResource";
-    return 0;
-  }
-
-  HANDLE sharedHandle;
-  hr = resource->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &sharedHandle);
-  if (FAILED(hr)) {
-    gfxCriticalNoteOnce << "GetSharedHandle failed: " << gfx::hexa(hr);
-    return 0;
-  }
-
-  RefPtr<gfx::FileHandleWrapper> handle =
-      new gfx::FileHandleWrapper(UniqueFileHandle(sharedHandle));
-
   return MakeUnique<ExternalTextureD3D11>(aWidth, aHeight, aFormat, aUsage,
-                                          texture, std::move(handle));
+                                          texture);
 }
 
 ExternalTextureD3D11::ExternalTextureD3D11(
     const uint32_t aWidth, const uint32_t aHeight,
     const struct ffi::WGPUTextureFormat aFormat,
-    const ffi::WGPUTextureUsages aUsage, const RefPtr<ID3D11Texture2D> aTexture,
-    RefPtr<gfx::FileHandleWrapper>&& aSharedHandle)
-    : ExternalTexture(aWidth, aHeight, aFormat, aUsage),
-      mTexture(aTexture),
-      mSharedHandle(std::move(aSharedHandle)) {
+    const ffi::WGPUTextureUsages aUsage, RefPtr<ID3D11Texture2D> aTexture)
+    : ExternalTexture(aWidth, aHeight, aFormat, aUsage), mTexture(aTexture) {
   MOZ_ASSERT(mTexture);
 }
 
 ExternalTextureD3D11::~ExternalTextureD3D11() {}
 
 void* ExternalTextureD3D11::GetExternalTextureHandle() {
-  if (!mSharedHandle) {
-    return nullptr;
+  RefPtr<IDXGIResource> resource;
+  mTexture->QueryInterface((IDXGIResource**)getter_AddRefs(resource));
+  if (!resource) {
+    gfxCriticalNoteOnce << "Failed to get IDXGIResource";
+    return 0;
   }
 
-  return mSharedHandle->GetHandle();
+  HANDLE sharedHandle;
+  HRESULT hr = resource->GetSharedHandle(&sharedHandle);
+  if (FAILED(hr)) {
+    gfxCriticalNoteOnce << "GetSharedHandle failed: " << gfx::hexa(hr);
+    return 0;
+  }
+  return sharedHandle;
 }
 
 Maybe<layers::SurfaceDescriptor> ExternalTextureD3D11::ToSurfaceDescriptor(
     Maybe<gfx::FenceInfo>& aFenceInfo) {
   const auto format = gfx::SurfaceFormat::B8G8R8A8;
   return Some(layers::SurfaceDescriptorD3D10(
-      mSharedHandle,
+      (WindowsHandle)GetExternalTextureHandle(),
       /* gpuProcessTextureId */ Nothing(),
       /* arrayIndex */ 0, format, gfx::IntSize(mWidth, mHeight),
       gfx::ColorSpace2::SRGB, gfx::ColorRange::FULL,
diff --git a/dom/webgpu/ExternalTextureD3D11.h b/dom/webgpu/ExternalTextureD3D11.h
index f6e0678d51bf..4eba0e02888c 100644
--- a/dom/webgpu/ExternalTextureD3D11.h
+++ b/dom/webgpu/ExternalTextureD3D11.h
@@ -6,7 +6,6 @@
 #ifndef GPU_ExternalTextureD3D11_H_
 #define GPU_ExternalTextureD3D11_H_
 
-#include "mozilla/gfx/FileHandleWrapper.h"
 #include "mozilla/webgpu/ExternalTexture.h"
 
 struct ID3D11Texture2D;
@@ -25,8 +24,7 @@ class ExternalTextureD3D11 final : public ExternalTexture {
   ExternalTextureD3D11(const uint32_t aWidth, const uint32_t aHeight,
                        const struct ffi::WGPUTextureFormat aFormat,
                        const ffi::WGPUTextureUsages aUsage,
-                       const RefPtr<ID3D11Texture2D> aTexture,
-                       RefPtr<gfx::FileHandleWrapper>&& aSharedHandle);
+                       RefPtr<ID3D11Texture2D> aTexture);
   virtual ~ExternalTextureD3D11();
 
   void* GetExternalTextureHandle() override;
@@ -37,8 +35,7 @@ class ExternalTextureD3D11 final : public ExternalTexture {
                    const gfx::IntSize& aSize) override;
 
  protected:
-  const RefPtr<ID3D11Texture2D> mTexture;
-  const RefPtr<gfx::FileHandleWrapper> mSharedHandle;
+  RefPtr<ID3D11Texture2D> mTexture;
 };
 
 }  // namespace webgpu
diff --git a/dom/webgpu/ipc/WebGPUParent.cpp b/dom/webgpu/ipc/WebGPUParent.cpp
index 3044ae186d8e..0e5f40c94daa 100644
--- a/dom/webgpu/ipc/WebGPUParent.cpp
+++ b/dom/webgpu/ipc/WebGPUParent.cpp
@@ -50,24 +50,12 @@ extern void* wgpu_server_get_external_texture_handle(void* aParam,
                                                      WGPUTextureId aId) {
   auto* parent = static_cast<WebGPUParent*>(aParam);
 
-  auto texture = parent->GetExternalTexture(aId);
-  if (!texture) {
-    MOZ_ASSERT_UNREACHABLE("unexpected to be called");
-    return nullptr;
-  }
-
-  void* sharedHandle = nullptr;
-#ifdef XP_WIN
-  sharedHandle = texture->GetExternalTextureHandle();
-  if (!sharedHandle) {
+  auto externalTexture = parent->GetExternalTexture(aId);
+  if (!externalTexture) {
     MOZ_ASSERT_UNREACHABLE("unexpected to be called");
-    gfxCriticalNoteOnce << "Failed to get shared handle";
     return nullptr;
   }
-#else
-  MOZ_ASSERT_UNREACHABLE("unexpected to be called");
-#endif
-  return sharedHandle;
+  return externalTexture->GetExternalTextureHandle();
 }
 
 extern int32_t wgpu_server_get_dma_buf_fd(void* aParam, WGPUTextureId aId) {
@@ -1474,6 +1462,13 @@ std::shared_ptr<ExternalTexture> WebGPUParent::CreateExternalTexture(
     return nullptr;
   }
 
+  auto* sharedHandle = texture->GetExternalTextureHandle();
+  if (!sharedHandle) {
+    MOZ_ASSERT_UNREACHABLE("unexpected to be called");
+    gfxCriticalNoteOnce << "Failed to get shared handle";
+    return nullptr;
+  }
+
   texture->SetOwnerId(aOwnerId);
   std::shared_ptr<ExternalTexture> shared(texture.release());
   mExternalTextures.emplace(aTextureId, shared);
diff --git a/gfx/gl/GLBlitHelperD3D.cpp b/gfx/gl/GLBlitHelperD3D.cpp
index 2ed1beded042..8f6645823be0 100644
--- a/gfx/gl/GLBlitHelperD3D.cpp
+++ b/gfx/gl/GLBlitHelperD3D.cpp
@@ -7,7 +7,6 @@
 #include "GLBlitHelper.h"
 
 #include <d3d11.h>
-#include <d3d11_1.h>
 
 #include "GLContextEGL.h"
 #include "GLLibraryEGL.h"
@@ -60,19 +59,12 @@ static EGLStreamKHR StreamFromD3DTexture(EglDisplay* const egl,
 
 static RefPtr<ID3D11Texture2D> OpenSharedTexture(ID3D11Device* const d3d,
                                                  const WindowsHandle handle) {
-  RefPtr<ID3D11Device1> device1;
-  d3d->QueryInterface((ID3D11Device1**)getter_AddRefs(device1));
-  if (!device1) {
-    gfxCriticalNoteOnce << "Failed to get ID3D11Device1";
-    return nullptr;
-  }
-
   RefPtr<ID3D11Texture2D> tex;
-  auto hr = device1->OpenSharedResource1(
-      (HANDLE)handle, __uuidof(ID3D11Texture2D),
-      (void**)(ID3D11Texture2D**)getter_AddRefs(tex));
+  auto hr =
+      d3d->OpenSharedResource((HANDLE)handle, __uuidof(ID3D11Texture2D),
+                              (void**)(ID3D11Texture2D**)getter_AddRefs(tex));
   if (FAILED(hr)) {
-    gfxCriticalError() << "Error code from OpenSharedResource1: "
+    gfxCriticalError() << "Error code from OpenSharedResource: "
                        << gfx::hexa(hr);
     return nullptr;
   }
@@ -259,6 +247,7 @@ bool GLBlitHelper::BlitDescriptor(const layers::SurfaceDescriptorD3D10& desc,
   const auto& d3d = GetD3D11();
   if (!d3d) return false;
 
+  const auto& handle = desc.handle();
   const auto& gpuProcessTextureId = desc.gpuProcessTextureId();
   const auto& arrayIndex = desc.arrayIndex();
   const auto& format = desc.format();
@@ -286,11 +275,11 @@ bool GLBlitHelper::BlitDescriptor(const layers::SurfaceDescriptorD3D10& desc,
         tex = OpenSharedTexture(d3d, (WindowsHandle)handle.ref());
       }
     }
-  } else if (desc.handle()) {
-    tex = OpenSharedTexture(d3d, (WindowsHandle)desc.handle()->GetHandle());
+  } else {
+    tex = OpenSharedTexture(d3d, handle);
   }
   if (!tex) {
-    MOZ_GL_ASSERT(mGL, false);  // Get a nullptr from OpenSharedResource1.
+    MOZ_GL_ASSERT(mGL, false);  // Get a nullptr from OpenSharedResource.
     return false;
   }
   const RefPtr<ID3D11Texture2D> texList[2] = {tex, tex};
@@ -360,12 +349,8 @@ bool GLBlitHelper::BlitDescriptor(
 
   const gfx::IntRect clipRect(0, 0, clipSize.width, clipSize.height);
 
-  auto handleY = desc.handleY() ? desc.handleY()->GetHandle() : nullptr;
-  auto handleCb = desc.handleCb() ? desc.handleCb()->GetHandle() : nullptr;
-  auto handleCr = desc.handleCr() ? desc.handleCr()->GetHandle() : nullptr;
-
-  const WindowsHandle handles[3] = {
-      (WindowsHandle)handleY, (WindowsHandle)handleCb, (WindowsHandle)handleCr};
+  const WindowsHandle handles[3] = {desc.handleY(), desc.handleCb(),
+                                    desc.handleCr()};
   return BlitAngleYCbCr(handles, clipRect, ySize, uvSize, colorSpace, destSize,
                         destOrigin);
 }
diff --git a/gfx/gl/SharedSurfaceANGLE.cpp b/gfx/gl/SharedSurfaceANGLE.cpp
index 0b343d172afb..36f25d5afea5 100644
--- a/gfx/gl/SharedSurfaceANGLE.cpp
+++ b/gfx/gl/SharedSurfaceANGLE.cpp
@@ -10,7 +10,6 @@
 #include "GLContextEGL.h"
 #include "GLLibraryEGL.h"
 #include "mozilla/gfx/DeviceManagerDx.h"
-#include "mozilla/gfx/FileHandleWrapper.h"
 #include "mozilla/layers/LayersSurfaces.h"  // for SurfaceDescriptor, etc
 
 namespace mozilla {
@@ -76,8 +75,7 @@ SharedSurface_ANGLEShareHandle::Create(const SharedSurfaceDesc& desc) {
   CD3D11_TEXTURE2D_DESC texDesc(
       format, desc.size.width, desc.size.height, 1, 1,
       D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET);
-  texDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                      D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  texDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
 
   RefPtr<ID3D11Texture2D> texture2D;
   auto hr =
@@ -86,20 +84,18 @@ SharedSurface_ANGLEShareHandle::Create(const SharedSurfaceDesc& desc) {
     return nullptr;
   }
 
-  RefPtr<IDXGIResource1> texDXGI;
-  hr = texture2D->QueryInterface(__uuidof(IDXGIResource1),
+  HANDLE shareHandle = nullptr;
+  RefPtr<IDXGIResource> texDXGI;
+  hr = texture2D->QueryInterface(__uuidof(IDXGIResource),
                                  getter_AddRefs(texDXGI));
   if (FAILED(hr)) {
     return nullptr;
   }
 
-  HANDLE sharedHandle = nullptr;
-  texDXGI->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &sharedHandle);
-
-  RefPtr<gfx::FileHandleWrapper> handle =
-      new gfx::FileHandleWrapper(UniqueFileHandle(sharedHandle));
+  hr = texDXGI->GetSharedHandle(&shareHandle);
+  if (FAILED(hr)) {
+    return nullptr;
+  }
 
   RefPtr<IDXGIKeyedMutex> keyedMutex;
   texture2D->QueryInterface((IDXGIKeyedMutex**)getter_AddRefs(keyedMutex));
@@ -114,18 +110,18 @@ SharedSurface_ANGLEShareHandle::Create(const SharedSurfaceDesc& desc) {
       CreatePBufferSurface(egl.get(), config, desc.size, texture2D);
   if (!pbuffer) return nullptr;
 
-  return AsUnique(new SharedSurface_ANGLEShareHandle(
-      desc, egl, pbuffer, std::move(handle), keyedMutex));
+  return AsUnique(new SharedSurface_ANGLEShareHandle(desc, egl, pbuffer,
+                                                     shareHandle, keyedMutex));
 }
 
 SharedSurface_ANGLEShareHandle::SharedSurface_ANGLEShareHandle(
     const SharedSurfaceDesc& desc, const std::weak_ptr<EglDisplay>& egl,
-    EGLSurface pbuffer, RefPtr<gfx::FileHandleWrapper>&& aSharedHandle,
+    EGLSurface pbuffer, HANDLE shareHandle,
     const RefPtr<IDXGIKeyedMutex>& keyedMutex)
     : SharedSurface(desc, nullptr),
       mEGL(egl),
       mPBuffer(pbuffer),
-      mSharedHandle(std::move(aSharedHandle)),
+      mShareHandle(shareHandle),
       mKeyedMutex(keyedMutex) {}
 
 SharedSurface_ANGLEShareHandle::~SharedSurface_ANGLEShareHandle() {
@@ -173,7 +169,7 @@ Maybe<layers::SurfaceDescriptor>
 SharedSurface_ANGLEShareHandle::ToSurfaceDescriptor() {
   const auto format = gfx::SurfaceFormat::B8G8R8A8;
   return Some(layers::SurfaceDescriptorD3D10(
-      mSharedHandle, /* gpuProcessTextureId */ Nothing(),
+      (WindowsHandle)mShareHandle, /* gpuProcessTextureId */ Nothing(),
       /* arrayIndex */ 0, format, mDesc.size, mDesc.colorSpace,
       gfx::ColorRange::FULL, /* hasKeyedMutex */ true,
       /* fenceInfo */ Nothing(), /* gpuProcessQueryId */ Nothing()));
diff --git a/gfx/gl/SharedSurfaceANGLE.h b/gfx/gl/SharedSurfaceANGLE.h
index 30967ea0f6a8..ec80dd88a79c 100644
--- a/gfx/gl/SharedSurfaceANGLE.h
+++ b/gfx/gl/SharedSurfaceANGLE.h
@@ -14,11 +14,6 @@ struct IDXGIKeyedMutex;
 struct ID3D11Texture2D;
 
 namespace mozilla {
-
-namespace gfx {
-class FileHandleWrapper;
-}  // namespace gfx
-
 namespace gl {
 
 class GLContext;
@@ -28,7 +23,7 @@ class SharedSurface_ANGLEShareHandle final : public SharedSurface {
  public:
   const std::weak_ptr<EglDisplay> mEGL;
   const EGLSurface mPBuffer;
-  const RefPtr<gfx::FileHandleWrapper> mSharedHandle;
+  const HANDLE mShareHandle;
   const RefPtr<IDXGIKeyedMutex> mKeyedMutex;
 
   static UniquePtr<SharedSurface_ANGLEShareHandle> Create(
@@ -37,8 +32,7 @@ class SharedSurface_ANGLEShareHandle final : public SharedSurface {
  private:
   SharedSurface_ANGLEShareHandle(const SharedSurfaceDesc&,
                                  const std::weak_ptr<EglDisplay>& egl,
-                                 EGLSurface pbuffer,
-                                 RefPtr<gfx::FileHandleWrapper>&& aSharedHandle,
+                                 EGLSurface pbuffer, HANDLE shareHandle,
                                  const RefPtr<IDXGIKeyedMutex>& keyedMutex);
 
  public:
diff --git a/gfx/gl/SharedSurfaceD3D11Interop.cpp b/gfx/gl/SharedSurfaceD3D11Interop.cpp
index 4c133b194a50..efd11d719258 100644
--- a/gfx/gl/SharedSurfaceD3D11Interop.cpp
+++ b/gfx/gl/SharedSurfaceD3D11Interop.cpp
@@ -14,7 +14,6 @@
 #include "WGLLibrary.h"
 #include "nsPrintfCString.h"
 #include "mozilla/gfx/DeviceManagerDx.h"
-#include "mozilla/gfx/FileHandleWrapper.h"
 #include "mozilla/gfx/Logging.h"
 #include "mozilla/layers/LayersSurfaces.h"
 #include "mozilla/StaticPrefs_webgl.h"
@@ -325,8 +324,7 @@ UniquePtr<SharedSurface_D3D11Interop> SharedSurface_D3D11Interop::Create(
   // Create a texture in case we need to readback.
   const DXGI_FORMAT format = DXGI_FORMAT_B8G8R8A8_UNORM;
   CD3D11_TEXTURE2D_DESC texDesc(format, size.width, size.height, 1, 1);
-  texDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                      D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  texDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
 
   auto hr =
       d3d->CreateTexture2D(&texDesc, nullptr, getter_AddRefs(data.texD3D));
@@ -335,20 +333,15 @@ UniquePtr<SharedSurface_D3D11Interop> SharedSurface_D3D11Interop::Create(
     return nullptr;
   }
 
-  RefPtr<IDXGIResource1> texDXGI;
-  hr = data.texD3D->QueryInterface(__uuidof(IDXGIResource1),
+  RefPtr<IDXGIResource> texDXGI;
+  hr = data.texD3D->QueryInterface(__uuidof(IDXGIResource),
                                    getter_AddRefs(texDXGI));
   if (FAILED(hr)) {
     NS_WARNING("Failed to open texture for sharing!");
     return nullptr;
   }
 
-  HANDLE sharedHandle = nullptr;
-  texDXGI->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &sharedHandle);
-
-  data.dxgiHandle = new gfx::FileHandleWrapper(UniqueFileHandle(sharedHandle));
+  texDXGI->GetSharedHandle(&data.dxgiHandle);
 
   ////
 
@@ -448,7 +441,7 @@ Maybe<layers::SurfaceDescriptor>
 SharedSurface_D3D11Interop::ToSurfaceDescriptor() {
   const auto format = gfx::SurfaceFormat::B8G8R8A8;
   return Some(layers::SurfaceDescriptorD3D10(
-      mData.dxgiHandle, /* gpuProcessTextureId */ Nothing(),
+      WindowsHandle(mData.dxgiHandle), /* gpuProcessTextureId */ Nothing(),
       /* arrayIndex */ 0, format, mDesc.size, mDesc.colorSpace,
       gfx::ColorRange::FULL, /* hasKeyedMutex */ true,
       /* fenceInfo */ Nothing(), /* gpuProcessQueryId */ Nothing()));
diff --git a/gfx/gl/SharedSurfaceD3D11Interop.h b/gfx/gl/SharedSurfaceD3D11Interop.h
index 229b74cc0589..58abcb12157e 100644
--- a/gfx/gl/SharedSurfaceD3D11Interop.h
+++ b/gfx/gl/SharedSurfaceD3D11Interop.h
@@ -11,11 +11,6 @@
 #include "SharedSurface.h"
 
 namespace mozilla {
-
-namespace gfx {
-class FileHandleWrapper;
-}  // namespace gfx
-
 namespace gl {
 
 class DXInterop2Device;
@@ -28,7 +23,7 @@ class SharedSurface_D3D11Interop final : public SharedSurface {
     const RefPtr<DXInterop2Device> interop;
     HANDLE lockHandle;
     RefPtr<ID3D11Texture2D> texD3D;
-    RefPtr<gfx::FileHandleWrapper> dxgiHandle;
+    HANDLE dxgiHandle;
     UniquePtr<Renderbuffer> interopRb;
     UniquePtr<MozFramebuffer> interopFbIfNeedsIndirect;
   };
diff --git a/gfx/ipc/FileHandleWrapper.cpp b/gfx/ipc/FileHandleWrapper.cpp
index 7597e27c1d8f..b5c0fb3fa90c 100644
--- a/gfx/ipc/FileHandleWrapper.cpp
+++ b/gfx/ipc/FileHandleWrapper.cpp
@@ -6,8 +6,6 @@
 
 #include "FileHandleWrapper.h"
 
-#include "mozilla/ipc/FileDescriptor.h"
-
 namespace mozilla::gfx {
 
 FileHandleWrapper::FileHandleWrapper(mozilla::UniqueFileHandle&& aHandle)
@@ -19,9 +17,4 @@ mozilla::detail::FileHandleType FileHandleWrapper::GetHandle() {
   return mHandle.get();
 }
 
-mozilla::UniqueFileHandle FileHandleWrapper::ClonePlatformHandle() {
-  auto handle = ipc::FileDescriptor(GetHandle());
-  return handle.TakePlatformHandle();
-}
-
 }  // namespace mozilla::gfx
diff --git a/gfx/ipc/FileHandleWrapper.h b/gfx/ipc/FileHandleWrapper.h
index 6ca905bd617d..09e2dd6ceab4 100644
--- a/gfx/ipc/FileHandleWrapper.h
+++ b/gfx/ipc/FileHandleWrapper.h
@@ -35,8 +35,6 @@ class FileHandleWrapper {
 
   mozilla::detail::FileHandleType GetHandle();
 
-  mozilla::UniqueFileHandle ClonePlatformHandle();
-
  protected:
   ~FileHandleWrapper();
 
diff --git a/gfx/layers/CompositorTypes.h b/gfx/layers/CompositorTypes.h
index 3375e9495c93..ba2358f8c648 100644
--- a/gfx/layers/CompositorTypes.h
+++ b/gfx/layers/CompositorTypes.h
@@ -13,7 +13,6 @@
 #include "LayersTypes.h"  // for LayersBackend, etc
 #include "nsXULAppAPI.h"  // for GeckoProcessType, etc
 #include "mozilla/gfx/Types.h"
-#include "mozilla/layers/SyncObject.h"
 #include "mozilla/EnumSet.h"
 
 #include "mozilla/TypedEnumBits.h"
@@ -148,6 +147,12 @@ enum class CompositableType : uint8_t {
   COUNT
 };
 
+#ifdef XP_WIN
+typedef void* SyncHandle;
+#else
+typedef uintptr_t SyncHandle;
+#endif  // XP_WIN
+
 /**
  * Sent from the compositor to the content-side LayerManager, includes
  * properties of the compositor and should (in the future) include information
@@ -175,7 +180,7 @@ struct TextureFactoryIdentifier {
       bool aCompositorUseDComp = false, bool aUseCompositorWnd = false,
       bool aSupportsTextureBlitting = false,
       bool aSupportsPartialUploads = false, bool aSupportsComponentAlpha = true,
-      bool aSupportsD3D11NV12 = false, SyncHandle aSyncHandle = {})
+      bool aSupportsD3D11NV12 = false, SyncHandle aSyncHandle = 0)
       : mParentBackend(aLayersBackend),
         mWebRenderBackend(WebRenderBackend::HARDWARE),
         mWebRenderCompositor(WebRenderCompositor::DRAW),
@@ -198,7 +203,7 @@ struct TextureFactoryIdentifier {
       bool aCompositorUseDComp = false, bool aUseCompositorWnd = false,
       bool aSupportsTextureBlitting = false,
       bool aSupportsPartialUploads = false, bool aSupportsComponentAlpha = true,
-      bool aSupportsD3D11NV12 = false, SyncHandle aSyncHandle = {})
+      bool aSupportsD3D11NV12 = false, SyncHandle aSyncHandle = 0)
       : mParentBackend(LayersBackend::LAYERS_WR),
         mWebRenderBackend(aWebRenderBackend),
         mWebRenderCompositor(aWebRenderCompositor),
diff --git a/gfx/layers/D3D11ShareHandleImage.cpp b/gfx/layers/D3D11ShareHandleImage.cpp
index 851b54c9175e..09e83f79fbc3 100644
--- a/gfx/layers/D3D11ShareHandleImage.cpp
+++ b/gfx/layers/D3D11ShareHandleImage.cpp
@@ -184,8 +184,7 @@ bool D3D11ShareHandleImage::AllocateTexture(D3D11RecycleAllocator* aAllocator,
     CD3D11_TEXTURE2D_DESC newDesc(
         DXGI_FORMAT_B8G8R8A8_UNORM, mSize.width, mSize.height, 1, 1,
         D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE);
-    newDesc.MiscFlags =
-        D3D11_RESOURCE_MISC_SHARED_NTHANDLE | D3D11_RESOURCE_MISC_SHARED;
+    newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED;
 
     HRESULT hr =
         aDevice->CreateTexture2D(&newDesc, nullptr, getter_AddRefs(mTexture));
@@ -347,7 +346,7 @@ RefPtr<ID3D11Texture2D> D3D11RecycleAllocator::GetStagingTextureNV12(
     desc.Usage = D3D11_USAGE_STAGING;
     desc.BindFlags = 0;
     desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
-    desc.MiscFlags = 0;
+    desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
     desc.SampleDesc.Count = 1;
 
     HRESULT hr = mDevice->CreateTexture2D(&desc, nullptr,
diff --git a/gfx/layers/D3D11YCbCrImage.cpp b/gfx/layers/D3D11YCbCrImage.cpp
index 397b7290c17d..ca34a484559b 100644
--- a/gfx/layers/D3D11YCbCrImage.cpp
+++ b/gfx/layers/D3D11YCbCrImage.cpp
@@ -418,8 +418,7 @@ already_AddRefed<TextureClient> DXGIYCbCrTextureAllocationHelper::Allocate(
                                     ? DXGI_FORMAT_R8_UNORM
                                     : DXGI_FORMAT_R16_UNORM,
                                 ySize.width, ySize.height, 1, 1);
-  newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                      D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
 
   RefPtr<ID3D10Multithread> mt;
   HRESULT hr = mDevice->QueryInterface((ID3D10Multithread**)getter_AddRefs(mt));
diff --git a/gfx/layers/SyncObject.h b/gfx/layers/SyncObject.h
index 14871c1bfad6..03590dd43694 100644
--- a/gfx/layers/SyncObject.h
+++ b/gfx/layers/SyncObject.h
@@ -7,7 +7,6 @@
 #ifndef MOZILLA_GFX_LAYERS_SYNCOBJECT_H
 #define MOZILLA_GFX_LAYERS_SYNCOBJECT_H
 
-#include "mozilla/gfx/FileHandleWrapper.h"
 #include "mozilla/RefCounted.h"
 
 struct ID3D11Device;
@@ -16,7 +15,7 @@ namespace mozilla {
 namespace layers {
 
 #ifdef XP_WIN
-typedef RefPtr<gfx::FileHandleWrapper> SyncHandle;
+typedef void* SyncHandle;
 #else
 typedef uintptr_t SyncHandle;
 #endif  // XP_WIN
diff --git a/gfx/layers/d3d11/GpuProcessD3D11TextureMap.cpp b/gfx/layers/d3d11/GpuProcessD3D11TextureMap.cpp
index 062aedac4aa6..1bb47c1ddf2f 100644
--- a/gfx/layers/d3d11/GpuProcessD3D11TextureMap.cpp
+++ b/gfx/layers/d3d11/GpuProcessD3D11TextureMap.cpp
@@ -99,8 +99,8 @@ Maybe<HANDLE> GpuProcessD3D11TextureMap::GetSharedHandleOfCopiedTexture(
       return Nothing();
     }
 
-    if (it->second.mCopiedTextureSharedHandle) {
-      return Some(it->second.mCopiedTextureSharedHandle->GetHandle());
+    if (it->second.mCopiedTextureSharedHandle.isSome()) {
+      return it->second.mCopiedTextureSharedHandle;
     }
 
     holder = it->second;
@@ -121,8 +121,7 @@ Maybe<HANDLE> GpuProcessD3D11TextureMap::GetSharedHandleOfCopiedTexture(
   CD3D11_TEXTURE2D_DESC newDesc(
       DXGI_FORMAT_NV12, holder.mSize.width, holder.mSize.height, 1, 1,
       D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE);
-  newDesc.MiscFlags =
-      D3D11_RESOURCE_MISC_SHARED_NTHANDLE | D3D11_RESOURCE_MISC_SHARED;
+  newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED;
 
   RefPtr<ID3D11Texture2D> copiedTexture;
   HRESULT hr =
@@ -144,23 +143,18 @@ Maybe<HANDLE> GpuProcessD3D11TextureMap::GetSharedHandleOfCopiedTexture(
   context->CopySubresourceRegion(copiedTexture, 0, 0, 0, 0, holder.mTexture,
                                  holder.mArrayIndex, &srcBox);
 
-  RefPtr<IDXGIResource1> resource;
-  copiedTexture->QueryInterface((IDXGIResource1**)getter_AddRefs(resource));
+  RefPtr<IDXGIResource> resource;
+  copiedTexture->QueryInterface((IDXGIResource**)getter_AddRefs(resource));
   if (!resource) {
     return Nothing();
   }
 
   HANDLE sharedHandle;
-  hr = resource->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &sharedHandle);
+  hr = resource->GetSharedHandle(&sharedHandle);
   if (FAILED(hr)) {
     return Nothing();
   }
 
-  RefPtr<gfx::FileHandleWrapper> handle =
-      new gfx::FileHandleWrapper(UniqueFileHandle(sharedHandle));
-
   RefPtr<ID3D11Query> query;
   CD3D11_QUERY_DESC desc(D3D11_QUERY_EVENT);
   hr = device->CreateQuery(&desc, getter_AddRefs(query));
@@ -193,10 +187,10 @@ Maybe<HANDLE> GpuProcessD3D11TextureMap::GetSharedHandleOfCopiedTexture(
     }
 
     it->second.mCopiedTexture = copiedTexture;
-    it->second.mCopiedTextureSharedHandle = handle;
+    it->second.mCopiedTextureSharedHandle = Some(sharedHandle);
   }
 
-  return Some(handle->GetHandle());
+  return Some(sharedHandle);
 }
 
 size_t GpuProcessD3D11TextureMap::GetWaitingTextureCount() const {
diff --git a/gfx/layers/d3d11/GpuProcessD3D11TextureMap.h b/gfx/layers/d3d11/GpuProcessD3D11TextureMap.h
index 6c348aa4d29d..8c2e86830fb1 100644
--- a/gfx/layers/d3d11/GpuProcessD3D11TextureMap.h
+++ b/gfx/layers/d3d11/GpuProcessD3D11TextureMap.h
@@ -75,7 +75,7 @@ class GpuProcessD3D11TextureMap {
     gfx::IntSize mSize;
     RefPtr<ZeroCopyUsageInfo> mZeroCopyUsageInfo;
     RefPtr<ID3D11Texture2D> mCopiedTexture;
-    RefPtr<gfx::FileHandleWrapper> mCopiedTextureSharedHandle;
+    Maybe<HANDLE> mCopiedTextureSharedHandle;
   };
 
   struct UpdatingTextureHolder {
diff --git a/gfx/layers/d3d11/TextureD3D11.cpp b/gfx/layers/d3d11/TextureD3D11.cpp
index e53cc9973bf0..439e531ee80b 100644
--- a/gfx/layers/d3d11/TextureD3D11.cpp
+++ b/gfx/layers/d3d11/TextureD3D11.cpp
@@ -16,10 +16,8 @@
 #include "mozilla/StaticPrefs_gfx.h"
 #include "mozilla/gfx/DataSurfaceHelpers.h"
 #include "mozilla/gfx/DeviceManagerDx.h"
-#include "mozilla/gfx/FileHandleWrapper.h"
 #include "mozilla/gfx/Logging.h"
 #include "mozilla/gfx/gfxVars.h"
-#include "mozilla/ipc/FileDescriptor.h"
 #include "mozilla/layers/CompositorBridgeChild.h"
 #include "mozilla/layers/D3D11ZeroCopyTextureImage.h"
 #include "mozilla/layers/GpuProcessD3D11QueryMap.h"
@@ -291,9 +289,7 @@ static void UnlockD3DTexture(
 }
 
 D3D11TextureData::D3D11TextureData(ID3D11Texture2D* aTexture,
-                                   uint32_t aArrayIndex,
-                                   RefPtr<gfx::FileHandleWrapper> aSharedHandle,
-                                   gfx::IntSize aSize,
+                                   uint32_t aArrayIndex, gfx::IntSize aSize,
                                    gfx::SurfaceFormat aFormat,
                                    TextureAllocationFlags aFlags)
     : mSize(aSize),
@@ -301,7 +297,6 @@ D3D11TextureData::D3D11TextureData(ID3D11Texture2D* aTexture,
       mNeedsClear(aFlags & ALLOC_CLEAR_BUFFER),
       mHasKeyedMutex(HasKeyedMutex(aTexture)),
       mTexture(aTexture),
-      mSharedHandle(std::move(aSharedHandle)),
       mArrayIndex(aArrayIndex),
       mAllocationFlags(aFlags) {
   MOZ_ASSERT(aTexture);
@@ -397,11 +392,22 @@ void D3D11TextureData::SyncWithObject(RefPtr<SyncObjectClient> aSyncObject) {
 
 bool D3D11TextureData::SerializeSpecific(
     SurfaceDescriptorD3D10* const aOutDesc) {
+  RefPtr<IDXGIResource> resource;
+  GetDXGIResource((IDXGIResource**)getter_AddRefs(resource));
+  if (!resource) {
+    return false;
+  }
+  HANDLE sharedHandle = 0;
   if (mGpuProcessTextureId.isNothing()) {
+    HRESULT hr = resource->GetSharedHandle(&sharedHandle);
+    if (FAILED(hr)) {
+      LOGD3D11("Error getting shared handle for texture.");
+      return false;
+    }
   }
   *aOutDesc = SurfaceDescriptorD3D10(
-      mSharedHandle, mGpuProcessTextureId, mArrayIndex, mFormat, mSize,
-      mColorSpace, mColorRange, /* hasKeyedMutex */ mHasKeyedMutex,
+      (WindowsHandle)sharedHandle, mGpuProcessTextureId, mArrayIndex, mFormat,
+      mSize, mColorSpace, mColorRange, /* hasKeyedMutex */ mHasKeyedMutex,
       /* fenceInfo */ Nothing(), mGpuProcessQueryId);
   return true;
 }
@@ -429,7 +435,7 @@ already_AddRefed<TextureClient> D3D11TextureData::CreateTextureClient(
     gfx::ColorRange aColorRange, KnowsCompositor* aKnowsCompositor,
     RefPtr<ZeroCopyUsageInfo> aUsageInfo) {
   D3D11TextureData* data = new D3D11TextureData(
-      aTexture, aIndex, nullptr, aSize, aFormat,
+      aTexture, aIndex, aSize, aFormat,
       TextureAllocationFlags::ALLOC_MANUAL_SYNCHRONIZATION);
   data->mColorSpace = aColorSpace;
   data->SetColorRange(aColorRange);
@@ -494,15 +500,13 @@ D3D11TextureData* D3D11TextureData::Create(IntSize aSize, SurfaceFormat aFormat,
     newDesc.Format = DXGI_FORMAT_P016;
   }
 
-  newDesc.MiscFlags =
-      D3D11_RESOURCE_MISC_SHARED_NTHANDLE | D3D11_RESOURCE_MISC_SHARED;
+  newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED;
   bool useKeyedMutex = false;
   if (!NS_IsMainThread()) {
     // On the main thread we use the syncobject to handle synchronization.
     if (!(aFlags & ALLOC_MANUAL_SYNCHRONIZATION)) {
-      newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                          D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+      newDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
       useKeyedMutex = true;
     }
   }
 
@@ -571,33 +575,10 @@ D3D11TextureData* D3D11TextureData::Create(IntSize aSize, SurfaceFormat aFormat,
     }
     UnlockD3DTexture(texture11.get(), SerializeWithMoz2D::Yes);
   }
-
-  RefPtr<IDXGIResource1> resource;
-  texture11->QueryInterface((IDXGIResource1**)getter_AddRefs(resource));
-  if (!resource) {
-    gfxCriticalNoteOnce << "Failed to get IDXGIResource";
-    return nullptr;
-  }
-
-  HANDLE sharedHandle;
-  HRESULT hr = resource->GetSharedHandle(&sharedHandle);
-  hr = resource->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &sharedHandle);
-  if (FAILED(hr)) {
-    gfxCriticalNoteOnce << "GetSharedHandle failed: " << gfx::hexa(hr);
-    return nullptr;
-  }
-
   texture11->SetPrivateDataInterface(
       sD3D11TextureUsage,
       new TextureMemoryMeasurer(newDesc.Width * newDesc.Height * 4));
-
-  RefPtr<gfx::FileHandleWrapper> handle =
-      new gfx::FileHandleWrapper(UniqueFileHandle(sharedHandle));
-
-  return new D3D11TextureData(texture11, 0, std::move(handle), aSize, aFormat,
-                              aFlags);
+  return new D3D11TextureData(texture11, 0, aSize, aFormat, aFlags);
 }
 
 void D3D11TextureData::Deallocate(LayersIPCChannel* aAllocator) {
@@ -611,6 +592,10 @@ TextureData* D3D11TextureData::CreateSimilar(
   return D3D11TextureData::Create(mSize, mFormat, aAllocFlags);
 }
 
+void D3D11TextureData::GetDXGIResource(IDXGIResource** aOutResource) {
+  mTexture->QueryInterface(aOutResource);
+}
+
 TextureFlags D3D11TextureData::GetTextureFlags() const {
   // With WebRender, resource open happens asynchronously on RenderThread.
   // During opening the resource on host side, TextureClient needs to be alive.
@@ -638,47 +623,35 @@ DXGIYCbCrTextureData* DXGIYCbCrTextureData::Create(
       sD3D11TextureUsage,
       new TextureMemoryMeasurer(aSizeCbCr.width * aSizeCbCr.height));
 
-  RefPtr<IDXGIResource1> resource;
+  RefPtr<IDXGIResource> resource;
 
-  aTextureY->QueryInterface((IDXGIResource1**)getter_AddRefs(resource));
+  aTextureY->QueryInterface((IDXGIResource**)getter_AddRefs(resource));
 
   HANDLE handleY;
-  HRESULT hr = resource->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &handleY);
+  HRESULT hr = resource->GetSharedHandle(&handleY);
   if (FAILED(hr)) {
     return nullptr;
   }
-  const RefPtr<gfx::FileHandleWrapper> sharedHandleY =
-      new gfx::FileHandleWrapper(UniqueFileHandle(handleY));
 
-  aTextureCb->QueryInterface((IDXGIResource1**)getter_AddRefs(resource));
+  aTextureCb->QueryInterface((IDXGIResource**)getter_AddRefs(resource));
 
   HANDLE handleCb;
-  hr = resource->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &handleCb);
+  hr = resource->GetSharedHandle(&handleCb);
   if (FAILED(hr)) {
     return nullptr;
   }
-  const RefPtr<gfx::FileHandleWrapper> sharedHandleCb =
-      new gfx::FileHandleWrapper(UniqueFileHandle(handleCb));
 
-  aTextureCr->QueryInterface((IDXGIResource1**)getter_AddRefs(resource));
+  aTextureCr->QueryInterface((IDXGIResource**)getter_AddRefs(resource));
   HANDLE handleCr;
-  hr = resource->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &handleCr);
+  hr = resource->GetSharedHandle(&handleCr);
   if (FAILED(hr)) {
     return nullptr;
   }
-  const RefPtr<gfx::FileHandleWrapper> sharedHandleCr =
-      new gfx::FileHandleWrapper(UniqueFileHandle(handleCr));
 
   DXGIYCbCrTextureData* texture = new DXGIYCbCrTextureData();
-  texture->mHandles[0] = sharedHandleY;
-  texture->mHandles[1] = sharedHandleCb;
-  texture->mHandles[2] = sharedHandleCr;
+  texture->mHandles[0] = handleY;
+  texture->mHandles[1] = handleCb;
+  texture->mHandles[2] = handleCr;
   texture->mD3D11Textures[0] = aTextureY;
   texture->mD3D11Textures[1] = aTextureCb;
   texture->mD3D11Textures[2] = aTextureCr;
@@ -701,9 +674,10 @@ void DXGIYCbCrTextureData::FillInfo(TextureData::Info& aInfo) const {
 
 void DXGIYCbCrTextureData::SerializeSpecific(
     SurfaceDescriptorDXGIYCbCr* const aOutDesc) {
-  *aOutDesc = SurfaceDescriptorDXGIYCbCr(mHandles[0], mHandles[1], mHandles[2],
-                                         mSize, mSizeY, mSizeCbCr, mColorDepth,
-                                         mYUVColorSpace, mColorRange);
+  *aOutDesc = SurfaceDescriptorDXGIYCbCr(
+      (WindowsHandle)mHandles[0], (WindowsHandle)mHandles[1],
+      (WindowsHandle)mHandles[2], mSize, mSizeY, mSizeCbCr, mColorDepth,
+      mYUVColorSpace, mColorRange);
 }
 
 bool DXGIYCbCrTextureData::Serialize(SurfaceDescriptor& aOutDescriptor) {
@@ -789,7 +763,7 @@ DXGITextureHostD3D11::DXGITextureHostD3D11(
 DXGITextureHostD3D11::DXGITextureHostD3D11(
     TextureFlags aFlags, const SurfaceDescriptorD3D10& aDescriptor)
     : TextureHost(TextureHostType::DXGI, aFlags),
-      mHandle(aDescriptor.handle()),
+      mHandle((HANDLE)aDescriptor.handle()),
       mGpuProcessTextureId(aDescriptor.gpuProcessTextureId()),
       mArrayIndex(aDescriptor.arrayIndex()),
       mGpuProcessQueryId(aDescriptor.gpuProcessQueryId()),
@@ -820,16 +794,9 @@ bool DXGITextureHostD3D11::EnsureTexture() {
     ID3D11Device* const aDevice, const HANDLE handle) {
   MOZ_ASSERT(aDevice);
 
-  RefPtr<ID3D11Device1> device1;
-  aDevice->QueryInterface((ID3D11Device1**)getter_AddRefs(device1));
-  if (!device1) {
-    gfxCriticalNoteOnce << "Failed to get ID3D11Device1";
-    return nullptr;
-  }
-
   RefPtr<ID3D11Texture2D> tex;
-  auto hr = device1->OpenSharedResource1(
-      (HANDLE)handle, __uuidof(ID3D11Texture2D),
+  auto hr = aDevice->OpenSharedResource(
+      (HANDLE)handle, __uuidof(ID3D11Texture2D),
       (void**)(ID3D11Texture2D**)getter_AddRefs(tex));
   if (FAILED(hr)) {
     gfxCriticalNote << "Error code from OpenSharedResource1: " << gfx::hexa(hr);
@@ -853,7 +853,7 @@ static RefPtr<ID3D11Texture2D> OpenSharedD3D11Texture(
       texture = textureMap->GetTexture(gpuProcessTextureId.ref());
     }
   } else if (handle) {
-    texture = OpenSharedD3D11Texture(aDevice, handle->GetHandle());
+    texture = OpenSharedD3D11Texture(aDevice, handle);
   }
 
   if (!texture) {
@@ -1126,9 +1093,9 @@ DXGIYCbCrTextureHostD3D11::DXGIYCbCrTextureHostD3D11(
       mColorDepth(aDescriptor.colorDepth()),
       mYUVColorSpace(aDescriptor.yUVColorSpace()),
       mColorRange(aDescriptor.colorRange()) {
-  mHandles[0] = aDescriptor.handleY();
-  mHandles[1] = aDescriptor.handleCb();
-  mHandles[2] = aDescriptor.handleCr();
+  mHandles[0] = (HANDLE)aDescriptor.handleY();
+  mHandles[1] = (HANDLE)aDescriptor.handleCb();
+  mHandles[2] = (HANDLE)aDescriptor.handleCr();
 }
 
 void DXGIYCbCrTextureHostD3D11::CreateRenderTexture(
@@ -1456,7 +1423,7 @@ static inline bool ShouldDevCrashOnSyncInitFailure() {
 }
 
 SyncObjectD3D11Host::SyncObjectD3D11Host(ID3D11Device* aDevice)
-    : mSyncHandle(nullptr), mDevice(aDevice) {
+    : mSyncHandle(0), mDevice(aDevice) {
   MOZ_ASSERT(aDevice);
 }
 
@@ -1464,8 +1431,7 @@ bool SyncObjectD3D11Host::Init() {
   CD3D11_TEXTURE2D_DESC desc(
       DXGI_FORMAT_B8G8R8A8_UNORM, 1, 1, 1, 1,
       D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET);
-  desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                   D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
 
   RefPtr<ID3D11Texture2D> texture;
   HRESULT hr =
@@ -1475,7 +1441,7 @@ bool SyncObjectD3D11Host::Init() {
     return false;
   }
 
-  hr = texture->QueryInterface((IDXGIResource1**)getter_AddRefs(mSyncTexture));
+  hr = texture->QueryInterface((IDXGIResource**)getter_AddRefs(mSyncTexture));
   if (FAILED(hr) || !mSyncTexture) {
     gfxWarning() << "Could not QI sync texture: " << gfx::hexa(hr);
     return false;
@@ -1488,10 +1454,7 @@ bool SyncObjectD3D11Host::Init() {
     return false;
   }
 
-  HANDLE sharedHandle;
-  hr = mSyncTexture->CreateSharedHandle(
-      nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE, nullptr,
-      &sharedHandle);
-  if (FAILED(hr)) {
+  hr = mSyncTexture->GetSharedHandle(&mSyncHandle);
+  if (FAILED(hr) || !mSyncHandle) {
     gfxWarning() << "Could not get sync texture shared handle: "
                  << gfx::hexa(hr);
@@ -1500,6 +1463,5 @@ bool SyncObjectD3D11Host::Init() {
     return false;
   }
-  mSyncHandle = new gfx::FileHandleWrapper(UniqueFileHandle(sharedHandle));
 
   return true;
 }
@@ -1549,22 +1511,11 @@ bool SyncObjectD3D11Client::Init(ID3D11Device* aDevice, bool aFallible) {
     return true;
   }
 
-  if (!mSyncHandle) {
-    return false;
-  }
-
-  RefPtr<ID3D11Device1> device1;
-  aDevice->QueryInterface((ID3D11Device1**)getter_AddRefs(device1));
-  if (!device1) {
-    gfxCriticalNoteOnce << "Failed to get ID3D11Device1";
-    return 0;
-  }
-
-  HRESULT hr = device1->OpenSharedResource1(
-      mSyncHandle->GetHandle(), __uuidof(ID3D11Texture2D),
+  HRESULT hr = aDevice->OpenSharedResource(
+      mSyncHandle, __uuidof(ID3D11Texture2D),
       (void**)(ID3D11Texture2D**)getter_AddRefs(mSyncTexture));
   if (FAILED(hr) || !mSyncTexture) {
-    gfxCriticalNote << "Failed to OpenSharedResource1 for SyncObjectD3D11: "
+    gfxCriticalNote << "Failed to OpenSharedResource for SyncObjectD3D11: "
                     << hexa(hr);
     if (!aFallible && ShouldDevCrashOnSyncInitFailure()) {
       gfxDevCrash(LogReason::D3D11FinalizeFrame)
diff --git a/gfx/layers/d3d11/TextureD3D11.h b/gfx/layers/d3d11/TextureD3D11.h
index a1b39aeaa8a5..6644cb064f3b 100644
--- a/gfx/layers/d3d11/TextureD3D11.h
+++ b/gfx/layers/d3d11/TextureD3D11.h
@@ -8,7 +8,7 @@
 #define MOZILLA_GFX_TEXTURED3D11_H
 
 #include <d3d11.h>
-#include <d3d11_1.h>
+
 #include <vector>
 
 #include "d3d9.h"
@@ -25,9 +25,8 @@
 namespace mozilla {
 
 namespace gfx {
-class FileHandleWrapper;
 struct FenceInfo;
-}  // namespace gfx
+}
 
 namespace gl {
 class GLBlitHelper;
@@ -122,10 +121,11 @@ class D3D11TextureData final : public TextureData {
 
  private:
   D3D11TextureData(ID3D11Texture2D* aTexture, uint32_t aArrayIndex,
-                   RefPtr<gfx::FileHandleWrapper> aSharedHandle,
                    gfx::IntSize aSize, gfx::SurfaceFormat aFormat,
                    TextureAllocationFlags aFlags);
 
+  void GetDXGIResource(IDXGIResource** aOutResource);
+
   bool PrepareDrawTargetInLock(OpenMode aMode);
 
   friend class gl::GLBlitHelper;
@@ -152,7 +152,6 @@ class D3D11TextureData final : public TextureData {
   const bool mHasKeyedMutex;
 
   RefPtr<ID3D11Texture2D> mTexture;
-  const RefPtr<gfx::FileHandleWrapper> mSharedHandle;
   Maybe<GpuProcessTextureId> mGpuProcessTextureId;
   uint32_t mArrayIndex = 0;
   const TextureAllocationFlags mAllocationFlags;
@@ -205,7 +204,7 @@ class DXGIYCbCrTextureData : public TextureData {
 
  protected:
   RefPtr<ID3D11Texture2D> mD3D11Textures[3];
-  RefPtr<gfx::FileHandleWrapper> mHandles[3];
+  HANDLE mHandles[3];
   gfx::IntSize mSize;
   gfx::IntSize mSizeY;
   gfx::IntSize mSizeCbCr;
@@ -390,7 +389,7 @@ class DXGITextureHostD3D11 : public TextureHost {
 
   DXGITextureHostD3D11* AsDXGITextureHostD3D11() override { return this; }
 
-  const RefPtr<gfx::FileHandleWrapper> mHandle;
+  HANDLE mHandle;
   const Maybe<GpuProcessTextureId> mGpuProcessTextureId;
   const uint32_t mArrayIndex;
   const Maybe<GpuProcessQueryId> mGpuProcessQueryId;
@@ -450,9 +449,7 @@ class DXGIYCbCrTextureHostD3D11 : public TextureHost {
   gfx::IntSize mSize;
   gfx::IntSize mSizeY;
   gfx::IntSize mSizeCbCr;
-  // Handles will be closed automatically when `UniqueFileHandle` gets
-  // destroyed.
-  RefPtr<gfx::FileHandleWrapper> mHandles[3];
+  HANDLE mHandles[3];
   bool mIsLocked;
   gfx::ColorDepth mColorDepth;
   gfx::YUVColorSpace mYUVColorSpace;
@@ -498,7 +495,7 @@ class SyncObjectD3D11Host : public SyncObjectHost {
 
   SyncHandle mSyncHandle;
   RefPtr<ID3D11Device> mDevice;
-  RefPtr<IDXGIResource1> mSyncTexture;
+  RefPtr<IDXGIResource> mSyncTexture;
   RefPtr<IDXGIKeyedMutex> mKeyedMutex;
 };
 
@@ -525,7 +522,7 @@ class SyncObjectD3D11Client : public SyncObjectClient {
   std::vector<ID3D11Texture2D*> mSyncedTextures;
 
  private:
-  SyncHandle mSyncHandle;
+  const SyncHandle mSyncHandle;
   RefPtr<IDXGIKeyedMutex> mKeyedMutex;
   const RefPtr<ID3D11Device> mDevice;
 };
diff --git a/gfx/layers/d3d11/TextureHostWrapperD3D11.cpp b/gfx/layers/d3d11/TextureHostWrapperD3D11.cpp
index 6152b31502f8..439950aaf4e8 100644
--- a/gfx/layers/d3d11/TextureHostWrapperD3D11.cpp
+++ b/gfx/layers/d3d11/TextureHostWrapperD3D11.cpp
@@ -245,7 +245,7 @@ RefPtr<TextureHost> TextureHostWrapperD3D11::CreateFromBufferTexture(
   auto colorSpace = ToColorSpace2(bufferTexture->GetYUVColorSpace());
 
   auto descD3D10 = SurfaceDescriptorD3D10(
-      nullptr, Some(id),
+      WindowsHandle(nullptr), Some(id),
       /* arrayIndex */ 0, gfx::SurfaceFormat::NV12, size, colorSpace,
       colorRange, /* hasKeyedMutex */ false, /* fenceInfo */ Nothing(),
       /* gpuProcessQueryId */ Nothing());
diff --git a/gfx/layers/ipc/LayersSurfaces.ipdlh b/gfx/layers/ipc/LayersSurfaces.ipdlh
index bef7301b8742..1fd21943bede 100644
--- a/gfx/layers/ipc/LayersSurfaces.ipdlh
+++ b/gfx/layers/ipc/LayersSurfaces.ipdlh
@@ -36,7 +35,7 @@ namespace mozilla {
 namespace layers {
 
 [Comparable] struct SurfaceDescriptorD3D10 {
-  nullable FileHandleWrapper handle;
+  WindowsHandle handle;
   GpuProcessTextureId? gpuProcessTextureId;
   uint32_t arrayIndex;
   SurfaceFormat format;
@@ -48,9 +47,9 @@ namespace layers {
 };
 
 [Comparable] struct SurfaceDescriptorDXGIYCbCr {
-  nullable FileHandleWrapper handleY;
-  nullable FileHandleWrapper handleCb;
-  nullable FileHandleWrapper handleCr;
+  WindowsHandle handleY;
+  WindowsHandle handleCb;
+  WindowsHandle handleCr;
   IntSize size;
   IntSize sizeY;
   IntSize sizeCbCr;
diff --git a/gfx/thebes/D3D11Checks.cpp b/gfx/thebes/D3D11Checks.cpp
index b3e3dd762fde..f729aebea829 100644
--- a/gfx/thebes/D3D11Checks.cpp
+++ b/gfx/thebes/D3D11Checks.cpp
@@ -21,7 +21,6 @@
 #include <dxgi1_2.h>
 #include <d3d10_1.h>
 #include <d3d11.h>
-#include <d3d11_1.h>
 
 namespace mozilla {
 namespace gfx {
@@ -57,8 +56,7 @@ bool D3D11Checks::DoesRenderTargetViewNeedRecreating(ID3D11Device* aDevice) {
   offscreenTextureDesc.BindFlags =
       D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;
   offscreenTextureDesc.CPUAccessFlags = 0;
-  offscreenTextureDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                                   D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  offscreenTextureDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
 
   HRESULT hr = aDevice->CreateTexture2D(&offscreenTextureDesc, NULL,
                                         getter_AddRefs(offscreenTexture));
@@ -244,8 +242,7 @@ static bool DoesTextureSharingWorkInternal(ID3D11Device* device,
   desc.SampleDesc.Quality = 0;
   desc.Usage = D3D11_USAGE_DEFAULT;
   desc.CPUAccessFlags = 0;
-  desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                   D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
   desc.BindFlags = bindflags;
 
   uint32_t color[texture_size * texture_size];
@@ -285,35 +282,23 @@ static bool DoesTextureSharingWorkInternal(ID3D11Device* device,
     return false;
   }
 
-  RefPtr<IDXGIResource1> otherResource;
-  if (FAILED(texture->QueryInterface(__uuidof(IDXGIResource1),
+  HANDLE shareHandle;
+  RefPtr<IDXGIResource> otherResource;
+  if (FAILED(texture->QueryInterface(__uuidof(IDXGIResource),
                                      getter_AddRefs(otherResource)))) {
     gfxCriticalError() << "DoesD3D11TextureSharingWork_GetResourceFailure";
     return false;
   }
 
-  HANDLE sharedHandle;
-  if (FAILED(otherResource->CreateSharedHandle(
-          nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE,
-          nullptr, &sharedHandle))) {
+  if (FAILED(otherResource->GetSharedHandle(&shareHandle))) {
     gfxCriticalError() << "DoesD3D11TextureSharingWork_GetSharedTextureFailure";
     return false;
   }
 
-  auto handle = ipc::FileDescriptor(UniqueFileHandle(sharedHandle));
-
-  RefPtr<ID3D11Device1> device1;
-  device->QueryInterface((ID3D11Device1**)getter_AddRefs(device1));
-  if (!device1) {
-    gfxCriticalNoteOnce << "Failed to get ID3D11Device1";
-    return false;
-  }
-
   RefPtr<ID3D11Resource> sharedResource;
   RefPtr<ID3D11Texture2D> sharedTexture;
-  auto raw = handle.TakePlatformHandle();
-  if (FAILED(device1->OpenSharedResource1(raw.get(), __uuidof(ID3D11Resource),
-                                          getter_AddRefs(sharedResource)))) {
+  if (FAILED(device->OpenSharedResource(shareHandle, __uuidof(ID3D11Resource),
+                                        getter_AddRefs(sharedResource)))) {
     gfxCriticalError(CriticalLog::DefaultOptions(false))
         << "OpenSharedResource failed for format " << format;
     return false;
diff --git a/gfx/vr/FxROutputHandler.cpp b/gfx/vr/FxROutputHandler.cpp
index c0f33e1b689c..3bf2fb62ce60 100644
--- a/gfx/vr/FxROutputHandler.cpp
+++ b/gfx/vr/FxROutputHandler.cpp
@@ -27,8 +27,7 @@ bool FxROutputHandler::TryInitialize(IDXGISwapChain* aSwapChain,
     // Create shareable texture, which will be copied to
     D3D11_TEXTURE2D_DESC descOrig = {0};
     texOrig->GetDesc(&descOrig);
-    descOrig.MiscFlags |=
-        D3D11_RESOURCE_MISC_SHARED_NTHANDLE | D3D11_RESOURCE_MISC_SHARED;
+    descOrig.MiscFlags |= D3D11_RESOURCE_MISC_SHARED;
     hr = aDevice->CreateTexture2D(&descOrig, nullptr,
                                   mTexCopy.StartAssignment());
     if (hr != S_OK) {
@@ -38,16 +37,14 @@ bool FxROutputHandler::TryInitialize(IDXGISwapChain* aSwapChain,
     // Now, share the texture to a handle that can be marshaled to another
     // process
     HANDLE hCopy = nullptr;
-    RefPtr<IDXGIResource1> texResource;
-    hr = mTexCopy->QueryInterface(IID_IDXGIResource1,
+    RefPtr<IDXGIResource> texResource;
+    hr = mTexCopy->QueryInterface(IID_IDXGIResource,
                                   getter_AddRefs(texResource));
     if (hr != S_OK) {
       return false;
     }
 
-    hr = texResource->CreateSharedHandle(
-        nullptr, DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE,
-        nullptr, &hCopy);
+    hr = texResource->GetSharedHandle(&hCopy);
     if (hr != S_OK) {
       return false;
     }
diff --git a/gfx/vr/VRManager.cpp b/gfx/vr/VRManager.cpp
index 5e3f349a60f0..2157439b92b1 100644
--- a/gfx/vr/VRManager.cpp
+++ b/gfx/vr/VRManager.cpp
@@ -1389,10 +1389,9 @@ bool VRManager::SubmitFrame(const layers::SurfaceDescriptor& aTexture,
     case SurfaceDescriptor::TSurfaceDescriptorD3D10: {
       const SurfaceDescriptorD3D10& surf =
           aTexture.get_SurfaceDescriptorD3D10();
-      auto handle = surf.handle()->ClonePlatformHandle();
       layer.textureType =
           VRLayerTextureType::LayerTextureType_D3D10SurfaceDescriptor;
-      layer.textureHandle = (void*)handle.release();
+      layer.textureHandle = (void*)surf.handle();
       layer.textureSize.width = surf.size().width;
       layer.textureSize.height = surf.size().height;
     } break;
diff --git a/gfx/vr/service/VRSession.cpp b/gfx/vr/service/VRSession.cpp
index 78c374dc9c0f..32f0af04c97b 100644
--- a/gfx/vr/service/VRSession.cpp
+++ b/gfx/vr/service/VRSession.cpp
@@ -8,8 +8,6 @@
 
 #include "moz_external_vr.h"
 
-#include "mozilla/ipc/FileDescriptor.h"
-
 #if defined(XP_WIN)
 #  include <d3d11.h>
 #endif  // defined(XP_WIN)
@@ -106,10 +104,8 @@ bool VRSession::SubmitFrame(
   if (aLayer.textureType ==
       VRLayerTextureType::LayerTextureType_D3D10SurfaceDescriptor) {
     ID3D11Texture2D* dxTexture = nullptr;
-    mozilla::ipc::FileDescriptor::UniquePlatformHandle handle(
-        aLayer.textureHandle);
-    HRESULT hr =
-        mDevice->OpenSharedResource1(handle.get(), IID_PPV_ARGS(&dxTexture));
+    HRESULT hr = mDevice->OpenSharedResource((HANDLE)aLayer.textureHandle,
+                                             IID_PPV_ARGS(&dxTexture));
     if (SUCCEEDED(hr) && dxTexture != nullptr) {
       // Similar to LockD3DTexture in TextureD3D11.cpp
       IDXGIKeyedMutex* mutex = nullptr;
diff --git a/gfx/webrender_bindings/RenderD3D11TextureHost.cpp b/gfx/webrender_bindings/RenderD3D11TextureHost.cpp
index b7a7ea7f43f9..b6738b6911ec 100644
--- a/gfx/webrender_bindings/RenderD3D11TextureHost.cpp
+++ b/gfx/webrender_bindings/RenderD3D11TextureHost.cpp
@@ -24,8 +24,7 @@ namespace mozilla {
 namespace wr {
 
 RenderDXGITextureHost::RenderDXGITextureHost(
-    const RefPtr<gfx::FileHandleWrapper> aHandle,
-    const Maybe<layers::GpuProcessTextureId>& aGpuProcessTextureId,
+    const HANDLE aHandle, const Maybe<layers::GpuProcessTextureId>& aGpuProcessTextureId,
     const uint32_t aArrayIndex, const gfx::SurfaceFormat aFormat,
     const gfx::ColorSpace2 aColorSpace, const gfx::ColorRange aColorRange,
     const gfx::IntSize aSize, bool aHasKeyedMutex,
@@ -215,16 +214,9 @@ bool RenderDXGITextureHost::EnsureD3D11Texture2D(ID3D11Device* aDevice) {
     return false;
   }
 
-  RefPtr<ID3D11Device1> device1;
-  aDevice->QueryInterface((ID3D11Device1**)getter_AddRefs(device1));
-  if (!device1) {
-    gfxCriticalNoteOnce << "Failed to get ID3D11Device1";
-    return 0;
-  }
-
   // Get the D3D11 texture from shared handle.
-  HRESULT hr = device1->OpenSharedResource1(
-      (HANDLE)mHandle->GetHandle(), __uuidof(ID3D11Texture2D),
+  HRESULT hr = aDevice->OpenSharedResource(
+      (HANDLE)mHandle, __uuidof(ID3D11Texture2D),
       (void**)(ID3D11Texture2D**)getter_AddRefs(mTexture));
   if (FAILED(hr)) {
     MOZ_ASSERT(false,
@@ -471,9 +463,9 @@ bool RenderDXGITextureHost::SyncObjectNeeded() {
 }
 
 RenderDXGIYCbCrTextureHost::RenderDXGIYCbCrTextureHost(
-    RefPtr<gfx::FileHandleWrapper> (&aHandles)[3],
-    gfx::YUVColorSpace aYUVColorSpace, gfx::ColorDepth aColorDepth,
-    gfx::ColorRange aColorRange, gfx::IntSize aSizeY, gfx::IntSize aSizeCbCr)
+    HANDLE (&aHandles)[3], gfx::YUVColorSpace aYUVColorSpace,
+    gfx::ColorDepth aColorDepth, gfx::ColorRange aColorRange,
+    gfx::IntSize aSizeY, gfx::IntSize aSizeCbCr)
     : mHandles{aHandles[0], aHandles[1], aHandles[2]},
       mSurfaces{0},
       mStreams{0},
@@ -594,13 +586,6 @@ bool RenderDXGIYCbCrTextureHost::EnsureLockable() {
 }
 
 bool RenderDXGIYCbCrTextureHost::EnsureD3D11Texture2D(ID3D11Device* aDevice) {
-  RefPtr<ID3D11Device1> device1;
-  aDevice->QueryInterface((ID3D11Device1**)getter_AddRefs(device1));
-  if (!device1) {
-    gfxCriticalNoteOnce << "Failed to get ID3D11Device1";
-    return false;
-  }
-
   if (mTextures[0]) {
     RefPtr<ID3D11Device> device;
     mTextures[0]->GetDevice(getter_AddRefs(device));
@@ -616,8 +601,8 @@ bool RenderDXGIYCbCrTextureHost::EnsureD3D11Texture2D(ID3D11Device* aDevice) {
 
   for (int i = 0; i < 3; ++i) {
     // Get the R8 D3D11 texture from shared handle.
-    HRESULT hr = device1->OpenSharedResource1(
-        (HANDLE)mHandles[i]->GetHandle(), __uuidof(ID3D11Texture2D),
+    HRESULT hr = aDevice->OpenSharedResource(
+        (HANDLE)mHandles[i], __uuidof(ID3D11Texture2D),
         (void**)(ID3D11Texture2D**)getter_AddRefs(mTextures[i]));
     if (FAILED(hr)) {
       NS_WARNING(
diff --git a/gfx/webrender_bindings/RenderD3D11TextureHost.h b/gfx/webrender_bindings/RenderD3D11TextureHost.h
index 4a4044e9e83a..5226f96acc78 100644
--- a/gfx/webrender_bindings/RenderD3D11TextureHost.h
+++ b/gfx/webrender_bindings/RenderD3D11TextureHost.h
@@ -27,8 +27,7 @@ namespace wr {
 class RenderDXGITextureHost final : public RenderTextureHostSWGL {
  public:
   RenderDXGITextureHost(
-      const RefPtr<gfx::FileHandleWrapper> aHandle,
-      const Maybe<layers::GpuProcessTextureId>& aGpuProcessTextureId,
+      const HANDLE aHandle, const Maybe<layers::GpuProcessTextureId>& aGpuProcessTextureId,
       const uint32_t aArrayIndex, const gfx::SurfaceFormat aFormat,
       const gfx::ColorSpace2 aColorSpace, const gfx::ColorRange aColorRange,
       const gfx::IntSize aSize, const bool aHasKeyedMutex,
@@ -100,7 +99,7 @@ class RenderDXGITextureHost final : public RenderTextureHostSWGL {
 
   RefPtr<gl::GLContext> mGL;
 
-  const RefPtr<gfx::FileHandleWrapper> mHandle;
+  const HANDLE mHandle;
   const Maybe<layers::GpuProcessTextureId> mGpuProcessTextureId;
   const Maybe<layers::GpuProcessQueryId> mGpuProcessQueryId;
   RefPtr<ID3D11Texture2D> mTexture;
@@ -136,10 +135,12 @@ class RenderDXGITextureHost final : public RenderTextureHostSWGL {
 
 class RenderDXGIYCbCrTextureHost final : public RenderTextureHostSWGL {
  public:
-  explicit RenderDXGIYCbCrTextureHost(
-      RefPtr<gfx::FileHandleWrapper> (&aHandles)[3],
-      gfx::YUVColorSpace aYUVColorSpace, gfx::ColorDepth aColorDepth,
-      gfx::ColorRange aColorRange, gfx::IntSize aSizeY, gfx::IntSize aSizeCbCr);
+  explicit RenderDXGIYCbCrTextureHost(HANDLE (&aHandles)[3],
+                                      gfx::YUVColorSpace aYUVColorSpace,
+                                      gfx::ColorDepth aColorDepth,
+                                      gfx::ColorRange aColorRange,
+                                      gfx::IntSize aSizeY,
+                                      gfx::IntSize aSizeCbCr);
 
   RenderDXGIYCbCrTextureHost* AsRenderDXGIYCbCrTextureHost() override {
     return this;
@@ -197,7 +198,7 @@ class RenderDXGIYCbCrTextureHost final : public RenderTextureHostSWGL {
 
   RefPtr<gl::GLContext> mGL;
 
-  RefPtr<gfx::FileHandleWrapper> mHandles[3];
+  HANDLE mHandles[3];
   RefPtr<ID3D11Texture2D> mTextures[3];
   RefPtr<IDXGIKeyedMutex> mKeyedMutexs[3];
 
diff --git a/gfx/webrender_bindings/WebRenderAPI.cpp b/gfx/webrender_bindings/WebRenderAPI.cpp
index 763497398518..c2a1af06c22b 100644
--- a/gfx/webrender_bindings/WebRenderAPI.cpp
+++ b/gfx/webrender_bindings/WebRenderAPI.cpp
@@ -339,7 +339,7 @@ already_AddRefed<WebRenderAPI> WebRenderAPI::Create(
   bool useDComp = false;
   bool useTripleBuffering = false;
   bool supportsExternalBufferTextures = false;
-  layers::SyncHandle syncHandle = {};
+  layers::SyncHandle syncHandle = 0;
 
   // Dispatch a synchronous task because the DocumentHandle object needs to be
   // created on the render thread. If need be we could delay waiting on this
