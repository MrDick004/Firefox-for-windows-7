diff --git a/browser/base/content/browser-init.js b/browser/base/content/browser-init.js
index 6ba29d2f28c9..b78eb1122470 100644
--- a/browser/base/content/browser-init.js
+++ b/browser/base/content/browser-init.js
@@ -1549,6 +1549,36 @@ var gBrowserInit = {
 
     new LightweightThemeConsumer(document);
 
+    if (AppConstants.platform == "win") {
+      if (
+        window.matchMedia("(-moz-platform: windows-win8)").matches &&
+        window.matchMedia("(-moz-windows-default-theme)").matches
+      ) {
+        let windowFrameColor = new Color(
+          ...ChromeUtils.importESModule(
+            "resource:///modules/Windows8WindowFrameColor.sys.mjs"
+          ).Windows8WindowFrameColor.get()
+        );
+        // Default to black for foreground text.
+        if (!windowFrameColor.isContrastRatioAcceptable(new Color(0, 0, 0))) {
+          document.documentElement.setAttribute("darkwindowframe", "true");
+        }
+      } else if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+        TelemetryEnvironment.onInitialized().then(() => {
+          // 17763 is the build number of Windows 10 version 1809
+          if (
+            TelemetryEnvironment.currentEnvironment.system.os
+              .windowsBuildNumber < 17763
+          ) {
+            document.documentElement.setAttribute(
+              "always-use-accent-color-for-window-border",
+              ""
+            );
+          }
+        });
+      }
+    }
+
     if (
       Services.prefs.getBoolPref(
         "toolkit.legacyUserProfileCustomizations.windowIcon",
diff --git a/browser/themes/Windows8WindowFrameColor.sys.mjs b/browser/themes/Windows8WindowFrameColor.sys.mjs
new file mode 100644
index 000000000000..dfca020255fa
--- /dev/null
+++ b/browser/themes/Windows8WindowFrameColor.sys.mjs
@@ -0,0 +1,55 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+import { WindowsRegistry as Registry } from "resource://gre/modules/WindowsRegistry.sys.mjs";
+
+export var Windows8WindowFrameColor = {
+  _windowFrameColor: null,
+
+  get() {
+    if (this._windowFrameColor) {
+      return this._windowFrameColor;
+    }
+
+    const HKCU = Ci.nsIWindowsRegKey.ROOT_KEY_CURRENT_USER;
+    const dwmKey = "Software\\Microsoft\\Windows\\DWM";
+    let customizationColor = Registry.readRegKey(
+      HKCU,
+      dwmKey,
+      "ColorizationColor"
+    );
+    if (customizationColor == undefined) {
+      // Seems to be the default color (hardcoded because of bug 1065998)
+      return [158, 158, 158];
+    }
+
+    // The color returned from the Registry is in decimal form.
+    let customizationColorHex = customizationColor.toString(16);
+
+    // Zero-pad the number just to make sure that it is 8 digits.
+    customizationColorHex = ("00000000" + customizationColorHex).substr(-8);
+    let customizationColorArray = customizationColorHex.match(/../g);
+    let [, fgR, fgG, fgB] = customizationColorArray.map(val =>
+      parseInt(val, 16)
+    );
+    let colorizationColorBalance = Registry.readRegKey(
+      HKCU,
+      dwmKey,
+      "ColorizationColorBalance"
+    );
+    if (colorizationColorBalance == undefined) {
+      colorizationColorBalance = 78;
+    }
+
+    // Window frame base color when Color Intensity is at 0, see bug 1004576.
+    let frameBaseColor = 217;
+    let alpha = colorizationColorBalance / 100;
+
+    // Alpha-blend the foreground color with the frame base color.
+    let r = Math.round(fgR * alpha + frameBaseColor * (1 - alpha));
+    let g = Math.round(fgG * alpha + frameBaseColor * (1 - alpha));
+    let b = Math.round(fgB * alpha + frameBaseColor * (1 - alpha));
+    return (this._windowFrameColor = [r, g, b]);
+  },
+};
diff --git a/browser/themes/moz.build b/browser/themes/moz.build
index 8940bd199f36..ea51211f9045 100644
--- a/browser/themes/moz.build
+++ b/browser/themes/moz.build
@@ -22,6 +22,11 @@ BROWSER_CHROME_MANIFESTS += [
 
 toolkit = CONFIG["MOZ_WIDGET_TOOLKIT"]
 
+if toolkit == "windows":
+    EXTRA_JS_MODULES += [
+        "Windows8WindowFrameColor.sys.mjs",
+    ]
+
 if toolkit == "cocoa":
     DIRS += ["osx"]
 elif toolkit == "gtk":
diff --git a/browser/themes/windows/browser-aero.css b/browser/themes/windows/browser-aero.css
index f6123829313f..ff578478b53f 100644
--- a/browser/themes/windows/browser-aero.css
+++ b/browser/themes/windows/browser-aero.css
@@ -35,6 +35,189 @@
     background-color: InactiveCaption;
     color: InactiveCaptionText;
   }
+}
+
+.titlebar-button {
+  appearance: none !important;
+  border: none;
+  margin: 0 !important;
+  padding: 8px 17px;
+  -moz-context-properties: stroke;
+  stroke: currentColor;
+
+  /* Win10's tablet mode is non-windowed -- windows can't be moved or resized
+     freely. In theory "minimize" might still make sense, but for simplicity we
+     just hide everything but "close".
+
+     (This is not called for in Win11's tablet mode, which _is_ windowed.)
+  */
+  :root[win10-tablet-mode] &:not(.titlebar-close) {
+    display: none;
+  }
+
+  &:focus-visible {
+    outline: var(--focus-outline);
+    outline-offset: var(--focus-outline-inset);
+  }
+
+  > .toolbarbutton-icon {
+    width: 12px;
+    height: 12px;
+
+    &:-moz-locale-dir(rtl) {
+      transform: scaleX(-1);
+    }
+  }
+}
+
+.titlebar-button > .toolbarbutton-icon {
+  width: 12px;
+  height: 12px;
+}
+
+.titlebar-min {
+  list-style-image: url(chrome://browser/skin/window-controls/minimize.svg);
+}
+
+.titlebar-max {
+  list-style-image: url(chrome://browser/skin/window-controls/maximize.svg);
+}
+
+.titlebar-restore {
+  list-style-image: url(chrome://browser/skin/window-controls/restore.svg);
+}
+
+.titlebar-restore > .toolbarbutton-icon:-moz-locale-dir(rtl) {
+  transform: scaleX(-1);
+}
+
+.titlebar-close {
+  list-style-image: url(chrome://browser/skin/window-controls/close.svg);
+}
+
+:root[lwtheme-image] .titlebar-button {
+  -moz-context-properties: unset;
+}
+:root[lwtheme-image] .titlebar-min {
+  list-style-image: url(chrome://browser/skin/window-controls/minimize-themes.svg);
+}
+:root[lwtheme-image] .titlebar-max {
+  list-style-image: url(chrome://browser/skin/window-controls/maximize-themes.svg);
+}
+:root[lwtheme-image] .titlebar-restore {
+  list-style-image: url(chrome://browser/skin/window-controls/restore-themes.svg);
+}
+:root[lwtheme-image] .titlebar-close {
+  list-style-image: url(chrome://browser/skin/window-controls/close-themes.svg);
+}
+
+/* the 12px image renders a 10px icon, and the 10px upscaled gets rounded to 12.5, which
+ * rounds up to 13px, which makes the icon one pixel too big on 1.25dppx. Fix: */
+@media (min-resolution: 1.20dppx) and (max-resolution: 1.45dppx) {
+  .titlebar-button > .toolbarbutton-icon {
+    width: 11.5px;
+    height: 11.5px;
+  }
+}
+
+/* 175% dpi should result in the same device pixel sizes as 150% dpi. */
+@media (min-resolution: 1.70dppx) and (max-resolution: 1.95dppx) {
+  .titlebar-button {
+    padding-inline: 14.1px;
+  }
+
+  .titlebar-button > .toolbarbutton-icon {
+    width: 10.8px;
+    height: 10.8px;
+  }
+}
+
+/* 225% dpi should result in the same device pixel sizes as 200% dpi. */
+@media (min-resolution: 2.20dppx) and (max-resolution: 2.45dppx) {
+  .titlebar-button {
+    padding-inline: 15.3333px;
+  }
+
+  .titlebar-button > .toolbarbutton-icon {
+    width: 10.8px;
+    height: 10.8px;
+  }
+}
+
+/* 275% dpi should result in the same device pixel sizes as 250% dpi. */
+@media (min-resolution: 2.70dppx) and (max-resolution: 2.95dppx) {
+  /* NB: todo: this should also change padding on the buttons
+   * themselves, but without a device to test this on, it's
+   * impossible to know by how much. */
+  .titlebar-button > .toolbarbutton-icon {
+    width: 10.8px;
+    height: 10.8px;
+  }
+}
+
+@media (-moz-windows-default-theme) {
+  #main-menubar > menu[_moz-menuactive="true"] {
+    color: inherit;
+  }
+
+  #main-menubar > menu[_moz-menuactive="true"],
+  .titlebar-button:hover {
+    background-color: hsla(0,0%,0%,.12);
+  }
+  .titlebar-button:hover:active {
+    background-color: hsla(0,0%,0%,.22);
+  }
+
+  #toolbar-menubar[brighttext] > #menubar-items > #main-menubar > menu[_moz-menuactive="true"],
+  toolbar[brighttext] .titlebar-button:not(.titlebar-close):hover {
+    background-color: hsla(0,0%,100%,.22);
+  }
+  toolbar[brighttext] .titlebar-button:not(.titlebar-close):hover:active {
+    background-color: hsla(0,0%,100%,.32);
+  }
+
+  .titlebar-close:hover {
+    stroke: white;
+    background-color: hsl(355,86%,49%);
+  }
+  .titlebar-close:hover:active {
+    background-color: hsl(355,82%,69%);
+  }
+
+  .titlebar-button:not(:hover) > .toolbarbutton-icon:-moz-window-inactive {
+    opacity: 0.5;
+  }
+}
+
+@media not (-moz-windows-default-theme) {
+  .titlebar-button {
+    background-color: -moz-field;
+    stroke: ButtonText;
+  }
+  .titlebar-button:hover {
+    background-color: SelectedItem;
+    stroke: SelectedItemText;
+  }
+
+  .titlebar-min {
+    list-style-image: url(chrome://browser/skin/window-controls/minimize-highcontrast.svg);
+  }
+
+  .titlebar-max {
+    list-style-image: url(chrome://browser/skin/window-controls/maximize-highcontrast.svg);
+  }
+
+  .titlebar-restore {
+    list-style-image: url(chrome://browser/skin/window-controls/restore-highcontrast.svg);
+  }
+
+  .titlebar-close {
+    list-style-image: url(chrome://browser/skin/window-controls/close-highcontrast.svg);
+  }
+
+  :root[darkwindowframe="true"]:not(:-moz-window-inactive, [lwtheme]) {
+    color: white;
+  }
 
   &:not([lwtheme]) #appcontent {
     background-color: -moz-dialog;
diff --git a/browser/themes/windows/browser.css b/browser/themes/windows/browser.css
index 7fc0b2c92e3c..cf2c519d67f5 100644
--- a/browser/themes/windows/browser.css
+++ b/browser/themes/windows/browser.css
@@ -114,6 +100,16 @@
 
 /* Titlebar */
 
+:root[tabsintitlebar][sizemode="normal"] #titlebar {
+  appearance: auto;
+  -moz-default-appearance: -moz-window-titlebar;
+}
+
+:root[tabsintitlebar][sizemode="maximized"] #titlebar {
+  appearance: auto;
+  -moz-default-appearance: -moz-window-titlebar-maximized;
+}
+
 .titlebar-buttonbox {
   appearance: none;
   /* The button box must appear on top of the navigator-toolbox in order for
@@ -131,180 +127,33 @@
 
 /* Window control buttons */
 
-.titlebar-button {
-  appearance: none;
-  border: none;
-  margin: 0;
-  padding: 8px 17px;
-  -moz-context-properties: stroke;
-  stroke: currentColor;
-
-  /* Win10's tablet mode is non-windowed -- windows can't be moved or resized
-     freely. In theory "minimize" might still make sense, but for simplicity we
-     just hide everything but "close".
-
-     (This is not called for in Win11's tablet mode, which _is_ windowed.)
-  */
-  :root[win10-tablet-mode] &:not(.titlebar-close) {
-    display: none;
-  }
-
-  &:focus-visible {
-    outline: var(--focus-outline);
-    outline-offset: var(--focus-outline-inset);
-  }
-
-  > .toolbarbutton-icon {
-    width: 12px;
-    height: 12px;
-
-    &:-moz-locale-dir(rtl) {
-      transform: scaleX(-1);
-    }
-  }
-}
-
 .titlebar-min {
-  /* Even though we use appearance: none, -moz-default-appearance is necessary
-   * for Windows 11's "snap layouts" feature, see
-   * DealWithWindowsAppearanceHacks */
+  appearance: auto;
   -moz-default-appearance: -moz-window-button-minimize;
-  list-style-image: url(chrome://browser/skin/window-controls/minimize.svg);
+  margin-inline-end: 2px;
 }
 
 .titlebar-max {
+  appearance: auto;
   -moz-default-appearance: -moz-window-button-maximize;
-  list-style-image: url(chrome://browser/skin/window-controls/maximize.svg);
 }
 
 .titlebar-restore {
+  appearance: auto;
   -moz-default-appearance: -moz-window-button-restore;
-  list-style-image: url(chrome://browser/skin/window-controls/restore.svg);
 }
 
 .titlebar-close {
+  appearance: auto;
   -moz-default-appearance: -moz-window-button-close;
-  list-style-image: url(chrome://browser/skin/window-controls/close.svg);
 }
 
-:root[tabletmode] .titlebar-button {
+:root[tabletmode] .titlebar-min,
+:root[tabletmode] .titlebar-restore,
+:root[tabletmode] .titlebar-max {
   display: none;
 }
 
-.titlebar-button > .toolbarbutton-icon {
-  width: 12px;
-  height: 12px;
-}
-
-.titlebar-restore > .toolbarbutton-icon:-moz-locale-dir(rtl) {
-  transform: scaleX(-1);
-}
-
-:root[lwtheme-image] .titlebar-button {
-  -moz-context-properties: unset;
-}
-:root[lwtheme-image] .titlebar-min {
-  list-style-image: url(chrome://browser/skin/window-controls/minimize-themes.svg);
-}
-:root[lwtheme-image] .titlebar-max {
-  list-style-image: url(chrome://browser/skin/window-controls/maximize-themes.svg);
-}
-:root[lwtheme-image] .titlebar-restore {
-  list-style-image: url(chrome://browser/skin/window-controls/restore-themes.svg);
-}
-:root[lwtheme-image] .titlebar-close {
-  list-style-image: url(chrome://browser/skin/window-controls/close-themes.svg);
-}
-
-@media (-moz-windows-default-theme) {
-  .titlebar-button:hover {
-    background-color: light-dark(hsla(0,0%,0%,.12), hsla(0,0%,100%,.22));
-  }
-  .titlebar-button:hover:active {
-    background-color: light-dark(hsla(0,0%,0%,.22), hsla(0,0%,100%,.32));
-  }
-
-  .titlebar-close:hover {
-    stroke: white;
-    background-color: hsl(355,86%,49%);
-  }
-
-  .titlebar-close:hover:active {
-    background-color: hsl(355,82%,69%);
-  }
-}
-
-@media not (-moz-windows-default-theme) {
-  .titlebar-button {
-    background-color: -moz-field;
-    stroke: ButtonText;
-  }
-  .titlebar-button:hover {
-    background-color: SelectedItem;
-    stroke: SelectedItemText;
-  }
-
-  .titlebar-min {
-    list-style-image: url(chrome://browser/skin/window-controls/minimize-highcontrast.svg);
-  }
-
-  .titlebar-max {
-    list-style-image: url(chrome://browser/skin/window-controls/maximize-highcontrast.svg);
-  }
-
-  .titlebar-restore {
-    list-style-image: url(chrome://browser/skin/window-controls/restore-highcontrast.svg);
-  }
-
-  .titlebar-close {
-    list-style-image: url(chrome://browser/skin/window-controls/close-highcontrast.svg);
-  }
-}
-
-/* the 12px image renders a 10px icon, and the 10px upscaled gets rounded to 12.5, which
- * rounds up to 13px, which makes the icon one pixel too big on 1.25dppx. Fix: */
-@media (1.20dppx <= resolution <= 1.45dppx) {
-  .titlebar-button > .toolbarbutton-icon {
-    width: 11.5px;
-    height: 11.5px;
-  }
-}
-
-/* 175% dpi should result in the same device pixel sizes as 150% dpi. */
-@media (1.70dppx <= resolution <= 1.95dppx) {
-  .titlebar-button {
-    padding-inline: 14.1px;
-  }
-
-  .titlebar-button > .toolbarbutton-icon {
-    width: 10.8px;
-    height: 10.8px;
-  }
-}
-
-/* 225% dpi should result in the same device pixel sizes as 200% dpi. */
-@media (2.20dppx <= resolution <= 2.45dppx) {
-  .titlebar-button {
-    padding-inline: 15.3333px;
-  }
-
-  .titlebar-button > .toolbarbutton-icon {
-    width: 10.8px;
-    height: 10.8px;
-  }
-}
-
-/* 275% dpi should result in the same device pixel sizes as 250% dpi. */
-@media (2.70dppx <= resolution <= 2.95dppx) {
-  /* NB: todo: this should also change padding on the buttons
-   * themselves, but without a device to test this on, it's
-   * impossible to know by how much. */
-  .titlebar-button > .toolbarbutton-icon {
-    width: 10.8px;
-    height: 10.8px;
-  }
-}
-
 /* Bookmark menus */
 
 menu.bookmark-item,
diff --git a/widget/windows/nsNativeThemeWin.cpp b/widget/windows/nsNativeThemeWin.cpp
index d3f9c86d8109..9cbc26bf0431 100644
--- a/widget/windows/nsNativeThemeWin.cpp
+++ b/widget/windows/nsNativeThemeWin.cpp
@@ -83,6 +83,55 @@ auto nsNativeThemeWin::IsWidgetNonNative(nsIFrame* aFrame,
   return NonNative::No;
 }
 
+static int32_t GetTopLevelWindowActiveState(nsIFrame* aFrame) {
+  // Used by window frame and button box rendering. We can end up in here in
+  // the content process when rendering one of these moz styles freely in a
+  // page. Bail in this case, there is no applicable window focus state.
+  if (!XRE_IsParentProcess()) {
+    return mozilla::widget::themeconst::FS_INACTIVE;
+  }
+  // All headless windows are considered active so they are painted.
+  if (gfxPlatform::IsHeadless()) {
+    return mozilla::widget::themeconst::FS_ACTIVE;
+  }
+  // Get the widget. nsIFrame's GetNearestWidget walks up the view chain
+  // until it finds a real window.
+  nsIWidget* widget = aFrame->GetNearestWidget();
+  nsWindow* window = static_cast<nsWindow*>(widget);
+  if (!window) return mozilla::widget::themeconst::FS_INACTIVE;
+  if (widget && !window->IsTopLevelWidget() &&
+      !(window = window->GetParentWindowBase(false)))
+    return mozilla::widget::themeconst::FS_INACTIVE;
+
+  if (window->GetWindowHandle() == ::GetActiveWindow())
+    return mozilla::widget::themeconst::FS_ACTIVE;
+  return mozilla::widget::themeconst::FS_INACTIVE;
+}
+
+static int32_t GetWindowFrameButtonState(nsIFrame* aFrame,
+                                         ElementState elementState) {
+  if (GetTopLevelWindowActiveState(aFrame) ==
+      mozilla::widget::themeconst::FS_INACTIVE) {
+    if (elementState.HasState(ElementState::HOVER))
+      return mozilla::widget::themeconst::BS_HOT;
+    return mozilla::widget::themeconst::BS_INACTIVE;
+  }
+
+  if (elementState.HasState(ElementState::HOVER)) {
+    if (elementState.HasState(ElementState::ACTIVE))
+      return mozilla::widget::themeconst::BS_PUSHED;
+    return mozilla::widget::themeconst::BS_HOT;
+  }
+  return mozilla::widget::themeconst::BS_NORMAL;
+}
+
+static int32_t GetClassicWindowFrameButtonState(ElementState elementState) {
+  if (elementState.HasState(ElementState::ACTIVE) &&
+      elementState.HasState(ElementState::HOVER))
+    return DFCS_BUTTONPUSH | DFCS_PUSHED;
+  return DFCS_BUTTONPUSH;
+}
+
 static bool IsTopLevelMenu(nsIFrame* aFrame) {
   auto* menu = dom::XULButtonElement::FromNodeOrNull(aFrame->GetContent());
   return menu && menu->IsOnMenuBar();
@@ -250,6 +299,72 @@ static HRESULT DrawThemeBGRTLAware(HANDLE aTheme, HDC aHdc, int aPart,
                              aClipRect);
 }
 
+/*
+ *  Caption button padding data - 'hot' button padding.
+ *  These areas are considered hot, in that they activate
+ *  a button when hovered or clicked. The button graphic
+ *  is drawn inside the padding border. Unrecognized themes
+ *  are treated as their recognized counterparts for now.
+ *                       left      top    right   bottom
+ *  classic min             1        2        0        1
+ *  classic max             0        2        1        1
+ *  classic close           1        2        2        1
+ *
+ *  aero basic min          1        2        0        2
+ *  aero basic max          0        2        1        2
+ *  aero basic close        1        2        1        2
+ *
+ *  'cold' button padding - generic button padding, should
+ *  be handled in css.
+ *                       left      top    right   bottom
+ *  classic min             0        0        0        0
+ *  classic max             0        0        0        0
+ *  classic close           0        0        0        0
+ *
+ *  aero basic min          0        0        1        0
+ *  aero basic max          1        0        0        0
+ *  aero basic close        0        0        0        0
+ */
+
+enum CaptionDesktopTheme {
+  CAPTION_CLASSIC = 0,
+  CAPTION_BASIC,
+};
+
+enum CaptionButton {
+  CAPTIONBUTTON_MINIMIZE = 0,
+  CAPTIONBUTTON_RESTORE,
+  CAPTIONBUTTON_CLOSE,
+};
+
+struct CaptionButtonPadding {
+  RECT hotPadding[3];
+};
+
+// RECT: left, top, right, bottom
+static CaptionButtonPadding buttonData[3] = {
+    {{{1, 2, 0, 1}, {0, 2, 1, 1}, {1, 2, 2, 1}}},
+    {{{1, 2, 0, 2}, {0, 2, 1, 2}, {1, 2, 2, 2}}},
+    {{{0, 2, 0, 2}, {0, 2, 1, 2}, {1, 2, 2, 2}}}};
+
+// Adds "hot" caption button padding to minimum widget size.
+static void AddPaddingRect(LayoutDeviceIntSize* aSize, CaptionButton button) {
+  if (!aSize) return;
+  RECT offset = buttonData[CAPTION_BASIC].hotPadding[button];
+  aSize->width += offset.left + offset.right;
+  aSize->height += offset.top + offset.bottom;
+}
+
+// If we've added padding to the minimum widget size, offset
+// the area we draw into to compensate.
+static void OffsetBackgroundRect(RECT& rect, CaptionButton button) {
+  RECT offset = buttonData[CAPTION_BASIC].hotPadding[button];
+  rect.left += offset.left;
+  rect.top += offset.top;
+  rect.right -= offset.right;
+  rect.bottom -= offset.bottom;
+}
+
 /*
  * Notes on progress track and meter part constants:
  * xp and up:
@@ -625,6 +740,13 @@ mozilla::Maybe<nsUXThemeClass> nsNativeThemeWin::GetThemeClass(
     case StyleAppearance::Menuimage:
     case StyleAppearance::Menuitemtext:
       return Some(eUXMenu);
+    case StyleAppearance::MozWindowTitlebar:
+    case StyleAppearance::MozWindowTitlebarMaximized:
+    case StyleAppearance::MozWindowButtonClose:
+    case StyleAppearance::MozWindowButtonMinimize:
+    case StyleAppearance::MozWindowButtonMaximize:
+    case StyleAppearance::MozWindowButtonRestore:
+      return Some(eUXWindowFrame);
     default:
       return Nothing();
   }
@@ -1145,6 +1267,35 @@ nsresult nsNativeThemeWin::GetThemePartAndState(nsIFrame* aFrame,
       aPart = -1;
       aState = 0;
       return NS_OK;
+
+    case StyleAppearance::MozWindowTitlebar:
+      aPart = mozilla::widget::themeconst::WP_CAPTION;
+      aState = GetTopLevelWindowActiveState(aFrame);
+      return NS_OK;
+    case StyleAppearance::MozWindowTitlebarMaximized:
+      aPart = mozilla::widget::themeconst::WP_MAXCAPTION;
+      aState = GetTopLevelWindowActiveState(aFrame);
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonClose:
+      aPart = mozilla::widget::themeconst::WP_CLOSEBUTTON;
+      aState = GetWindowFrameButtonState(aFrame,
+                                         GetContentState(aFrame, aAppearance));
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonMinimize:
+      aPart = mozilla::widget::themeconst::WP_MINBUTTON;
+      aState = GetWindowFrameButtonState(aFrame,
+                                         GetContentState(aFrame, aAppearance));
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonMaximize:
+      aPart = mozilla::widget::themeconst::WP_MAXBUTTON;
+      aState = GetWindowFrameButtonState(aFrame,
+                                         GetContentState(aFrame, aAppearance));
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonRestore:
+      aPart = mozilla::widget::themeconst::WP_RESTOREBUTTON;
+      aState = GetWindowFrameButtonState(aFrame,
+                                         GetContentState(aFrame, aAppearance));
+      return NS_OK;
     default:
       aPart = 0;
       aState = 0;
@@ -1198,6 +1349,24 @@ nsNativeThemeWin::DrawWidgetBackground(gfxContext* aContext, nsIFrame* aFrame,
                                        aDirtyRect);
 
   // ^^ without the right sdk, assume xp theming and fall through.
+  switch (aAppearance) {
+    case StyleAppearance::MozWindowTitlebar:
+    case StyleAppearance::MozWindowTitlebarMaximized:
+      // Nothing to draw, these areas are glass. Minimum dimensions
+      // should be set, so xul content should be laid out correctly.
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonClose:
+    case StyleAppearance::MozWindowButtonMinimize:
+    case StyleAppearance::MozWindowButtonMaximize:
+    case StyleAppearance::MozWindowButtonRestore:
+      // Not conventional bitmaps, can't be retrieved. If we fall
+      // through here and call the theme library we'll get aero
+      // basic bitmaps.
+      return NS_OK;
+    default:
+      break;
+  }
+
   int32_t part, state;
   nsresult rv = GetThemePartAndState(aFrame, aAppearance, part, state);
   if (NS_FAILED(rv)) return rv;
@@ -1247,7 +1416,17 @@ RENDER_AGAIN:
   }
 #endif
 
-  if (aAppearance == StyleAppearance::Tab) {
+  if (aAppearance == StyleAppearance::MozWindowTitlebar) {
+    // Clip out the left and right corners of the frame, all we want in
+    // is the middle section.
+    widgetRect.left -= GetSystemMetrics(SM_CXFRAME);
+    widgetRect.right += GetSystemMetrics(SM_CXFRAME);
+  } else if (aAppearance == StyleAppearance::MozWindowTitlebarMaximized) {
+    // The origin of the window is off screen when maximized and windows
+    // doesn't compensate for this in rendering the background. Push the
+    // top of the bitmap down by SM_CYFRAME so we get the full graphic.
+    widgetRect.top += GetSystemMetrics(SM_CYFRAME);
+  } else if (aAppearance == StyleAppearance::Tab) {
     // For left edge and right edge tabs, we need to adjust the widget
     // rects and clip rects so that the edges don't get drawn.
     bool isLeft = IsLeftToSelectedTab(aFrame);
@@ -1272,6 +1451,13 @@ RENDER_AGAIN:
         // back.
         widgetRect.left -= edgeSize;
     }
+  } else if (aAppearance == StyleAppearance::MozWindowButtonMinimize) {
+    OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_MINIMIZE);
+  } else if (aAppearance == StyleAppearance::MozWindowButtonMaximize ||
+             aAppearance == StyleAppearance::MozWindowButtonRestore) {
+    OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_RESTORE);
+  } else if (aAppearance == StyleAppearance::MozWindowButtonClose) {
+    OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_CLOSE);
   }
 
   // widgetRect is the bounding box for a widget, yet the scale track is only
@@ -1551,7 +1737,9 @@ LayoutDeviceIntMargin nsNativeThemeWin::GetWidgetBorder(
       aAppearance == StyleAppearance::Menupopup ||
       aAppearance == StyleAppearance::Menuimage ||
       aAppearance == StyleAppearance::Menuitemtext ||
-      aAppearance == StyleAppearance::Separator)
+      aAppearance == StyleAppearance::Separator ||
+      aAppearance == StyleAppearance::MozWindowTitlebar ||
+      aAppearance == StyleAppearance::MozWindowTitlebarMaximized)
     return result;  // Don't worry about it.
 
   int32_t part, state;
@@ -1613,6 +1801,33 @@ bool nsNativeThemeWin::GetWidgetPadding(nsDeviceContext* aContext,
 
   bool ok = true;
 
+  // Content padding
+  if (aAppearance == StyleAppearance::MozWindowTitlebar ||
+      aAppearance == StyleAppearance::MozWindowTitlebarMaximized) {
+    aResult->SizeTo(0, 0, 0, 0);
+    // Prior to Windows 10, a bug in DwmDefWindowProc would cause window
+    // button presses/mouseovers to be missed.  This bug is circumvented by
+    // adding padding to the top of the window that is the size of the caption
+    // area and then "removing" it when calculating the client area for
+    // WM_NCCALCSIZE.  See bug 618353,
+    if (!IsWin10OrLater() &&
+        aAppearance == StyleAppearance::MozWindowTitlebarMaximized) {
+      nsCOMPtr<nsIWidget> rootWidget;
+      if (WinUtils::HasSystemMetricsForDpi()) {
+        rootWidget = aFrame->PresContext()->GetRootWidget();
+      }
+      if (rootWidget) {
+        double dpi = rootWidget->GetDPI();
+        aResult->top = WinUtils::GetSystemMetricsForDpi(SM_CYFRAME, dpi) +
+                       WinUtils::GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
+      } else {
+        aResult->top =
+            GetSystemMetrics(SM_CYFRAME) + GetSystemMetrics(SM_CXPADDEDBORDER);
+      }
+    }
+    return ok;
+  }
+
   HANDLE theme = GetTheme(aAppearance);
   if (!theme) {
     ok = ClassicGetWidgetPadding(aContext, aFrame, aAppearance, aResult);
@@ -1855,6 +2070,16 @@ LayoutDeviceIntSize nsNativeThemeWin::GetMinimumWidgetSize(
       }
       break;
 
+    case StyleAppearance::MozWindowTitlebar:
+    case StyleAppearance::MozWindowTitlebarMaximized: {
+      LayoutDeviceIntSize result;
+      result.height = GetSystemMetrics(SM_CYCAPTION);
+      result.height += GetSystemMetrics(SM_CYFRAME);
+      result.height += GetSystemMetrics(SM_CXPADDEDBORDER);
+      ScaleForFrameDPI(&result, aFrame);
+      return result;
+    }
+
     default:
       break;
   }
@@ -1892,6 +2117,15 @@ nsNativeThemeWin::WidgetStateChanged(nsIFrame* aFrame,
     return false;
   }
 
+  if (aAppearance == StyleAppearance::MozWindowTitlebar ||
+      aAppearance == StyleAppearance::MozWindowTitlebarMaximized ||
+      aAppearance == StyleAppearance::MozWindowButtonClose ||
+      aAppearance == StyleAppearance::MozWindowButtonMinimize ||
+      aAppearance == StyleAppearance::MozWindowButtonMaximize ||
+      aAppearance == StyleAppearance::MozWindowButtonRestore) {
+    return true;
+  }
+
   return Theme::WidgetAttributeChangeRequiresRepaint(aAppearance, aAttribute);
 }
 
@@ -1952,7 +2187,7 @@ bool nsNativeThemeWin::ThemeSupportsWidget(nsPresContext* aPresContext,
 
   if (theme || ClassicThemeSupportsWidget(aFrame, aAppearance))
     // turn off theming for some HTML widgets styled by the page
-    return !IsWidgetStyled(aPresContext, aFrame, aAppearance);
+    return (!IsWidgetStyled(aPresContext, aFrame, aAppearance));
 
   return false;
 }
@@ -1985,6 +2220,21 @@ bool nsNativeThemeWin::ThemeDrawsFocusForWidget(nsIFrame* aFrame,
 
 bool nsNativeThemeWin::ThemeNeedsComboboxDropmarker() { return true; }
 
+bool nsNativeThemeWin::WidgetAppearanceDependsOnWindowFocus(
+    StyleAppearance aAppearance) {
+  switch (aAppearance) {
+    case StyleAppearance::MozWindowTitlebar:
+    case StyleAppearance::MozWindowTitlebarMaximized:
+    case StyleAppearance::MozWindowButtonClose:
+    case StyleAppearance::MozWindowButtonMinimize:
+    case StyleAppearance::MozWindowButtonMaximize:
+    case StyleAppearance::MozWindowButtonRestore:
+      return true;
+    default:
+      return false;
+  }
+}
+
 nsITheme::Transparency nsNativeThemeWin::GetWidgetTransparency(
     nsIFrame* aFrame, StyleAppearance aAppearance) {
   if (IsWidgetNonNative(aFrame, aAppearance) != NonNative::No) {
@@ -2062,6 +2312,12 @@ bool nsNativeThemeWin::ClassicThemeSupportsWidget(nsIFrame* aFrame,
     case StyleAppearance::Menuarrow:
     case StyleAppearance::Menuseparator:
     case StyleAppearance::Menuitemtext:
+    case StyleAppearance::MozWindowTitlebar:
+    case StyleAppearance::MozWindowTitlebarMaximized:
+    case StyleAppearance::MozWindowButtonClose:
+    case StyleAppearance::MozWindowButtonMinimize:
+    case StyleAppearance::MozWindowButtonMaximize:
+    case StyleAppearance::MozWindowButtonRestore:
       return true;
     default:
       return false;
@@ -2189,6 +2445,31 @@ LayoutDeviceIntSize nsNativeThemeWin::ClassicGetMinimumWidgetSize(
       break;
     }
 
+    case StyleAppearance::MozWindowTitlebarMaximized:
+    case StyleAppearance::MozWindowTitlebar:
+      result.height =
+          GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYFRAME);
+      break;
+    case StyleAppearance::MozWindowButtonClose:
+    case StyleAppearance::MozWindowButtonMinimize:
+    case StyleAppearance::MozWindowButtonMaximize:
+    case StyleAppearance::MozWindowButtonRestore:
+      result.width = GetSystemMetrics(SM_CXSIZE);
+      result.height = GetSystemMetrics(SM_CYSIZE);
+      // XXX I have no idea why these caption metrics are always off,
+      // but they are.
+      result.width -= 2;
+      result.height -= 4;
+      if (aAppearance == StyleAppearance::MozWindowButtonMinimize) {
+        AddPaddingRect(&result, CAPTIONBUTTON_MINIMIZE);
+      } else if (aAppearance == StyleAppearance::MozWindowButtonMaximize ||
+                 aAppearance == StyleAppearance::MozWindowButtonRestore) {
+        AddPaddingRect(&result, CAPTIONBUTTON_RESTORE);
+      } else if (aAppearance == StyleAppearance::MozWindowButtonClose) {
+        AddPaddingRect(&result, CAPTIONBUTTON_CLOSE);
+      }
+      break;
+
     default:
       break;
   }
@@ -2410,6 +2691,34 @@ nsresult nsNativeThemeWin::ClassicGetThemePartAndState(
       aPart = 0;
       aState = 0;
       return NS_OK;
+    case StyleAppearance::MozWindowTitlebar:
+      aPart = mozilla::widget::themeconst::WP_CAPTION;
+      aState = GetTopLevelWindowActiveState(aFrame);
+      return NS_OK;
+    case StyleAppearance::MozWindowTitlebarMaximized:
+      aPart = mozilla::widget::themeconst::WP_MAXCAPTION;
+      aState = GetTopLevelWindowActiveState(aFrame);
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonClose:
+      aPart = DFC_CAPTION;
+      aState = DFCS_CAPTIONCLOSE | GetClassicWindowFrameButtonState(
+                                       GetContentState(aFrame, aAppearance));
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonMinimize:
+      aPart = DFC_CAPTION;
+      aState = DFCS_CAPTIONMIN | GetClassicWindowFrameButtonState(
+                                     GetContentState(aFrame, aAppearance));
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonMaximize:
+      aPart = DFC_CAPTION;
+      aState = DFCS_CAPTIONMAX | GetClassicWindowFrameButtonState(
+                                     GetContentState(aFrame, aAppearance));
+      return NS_OK;
+    case StyleAppearance::MozWindowButtonRestore:
+      aPart = DFC_CAPTION;
+      aState = DFCS_CAPTIONRESTORE | GetClassicWindowFrameButtonState(
+                                         GetContentState(aFrame, aAppearance));
+      return NS_OK;
     default:
       return NS_ERROR_FAILURE;
   }
@@ -2733,6 +3042,82 @@ RENDER_AGAIN:
       break;
     }
 
+    case StyleAppearance::MozWindowTitlebar:
+    case StyleAppearance::MozWindowTitlebarMaximized: {
+      RECT rect = widgetRect;
+      int32_t offset = GetSystemMetrics(SM_CXFRAME);
+
+      // first fill the area to the color of the window background
+      ::FillRect(hdc, &rect, (HBRUSH)(COLOR_3DFACE + 1));
+
+      // inset the caption area so it doesn't overflow.
+      rect.top += offset;
+      // if enabled, draw a gradient titlebar background, otherwise
+      // fill with a solid color.
+      BOOL bFlag = TRUE;
+      SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, &bFlag, 0);
+      if (!bFlag) {
+        if (state == mozilla::widget::themeconst::FS_ACTIVE)
+          ::FillRect(hdc, &rect, (HBRUSH)(COLOR_ACTIVECAPTION + 1));
+        else
+          ::FillRect(hdc, &rect, (HBRUSH)(COLOR_INACTIVECAPTION + 1));
+      } else {
+        DWORD startColor, endColor;
+        if (state == mozilla::widget::themeconst::FS_ACTIVE) {
+          startColor = GetSysColor(COLOR_ACTIVECAPTION);
+          endColor = GetSysColor(COLOR_GRADIENTACTIVECAPTION);
+        } else {
+          startColor = GetSysColor(COLOR_INACTIVECAPTION);
+          endColor = GetSysColor(COLOR_GRADIENTINACTIVECAPTION);
+        }
+
+        TRIVERTEX vertex[2];
+        vertex[0].x = rect.left;
+        vertex[0].y = rect.top;
+        vertex[0].Red = GetRValue(startColor) << 8;
+        vertex[0].Green = GetGValue(startColor) << 8;
+        vertex[0].Blue = GetBValue(startColor) << 8;
+        vertex[0].Alpha = 0;
+
+        vertex[1].x = rect.right;
+        vertex[1].y = rect.bottom;
+        vertex[1].Red = GetRValue(endColor) << 8;
+        vertex[1].Green = GetGValue(endColor) << 8;
+        vertex[1].Blue = GetBValue(endColor) << 8;
+        vertex[1].Alpha = 0;
+
+        GRADIENT_RECT gRect;
+        gRect.UpperLeft = 0;
+        gRect.LowerRight = 1;
+        // available on win2k & up
+        GradientFill(hdc, vertex, 2, &gRect, 1, GRADIENT_FILL_RECT_H);
+      }
+
+      if (aAppearance == StyleAppearance::MozWindowTitlebar) {
+        // frame things up with a top raised border.
+        DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_TOP);
+      }
+      break;
+    }
+
+    case StyleAppearance::MozWindowButtonClose:
+    case StyleAppearance::MozWindowButtonMinimize:
+    case StyleAppearance::MozWindowButtonMaximize:
+    case StyleAppearance::MozWindowButtonRestore: {
+      if (aAppearance == StyleAppearance::MozWindowButtonMinimize) {
+        OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_MINIMIZE);
+      } else if (aAppearance == StyleAppearance::MozWindowButtonMaximize ||
+                 aAppearance == StyleAppearance::MozWindowButtonRestore) {
+        OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_RESTORE);
+      } else if (aAppearance == StyleAppearance::MozWindowButtonClose) {
+        OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_CLOSE);
+      }
+      int32_t oldTA = SetTextAlign(hdc, TA_TOP | TA_LEFT | TA_NOUPDATECP);
+      DrawFrameControl(hdc, &widgetRect, part, state);
+      SetTextAlign(hdc, oldTA);
+      break;
+    }
+
     default:
       rv = NS_ERROR_FAILURE;
       break;
diff --git a/widget/windows/nsNativeThemeWin.h b/widget/windows/nsNativeThemeWin.h
index 1c28d070aa46..00eff1622e0a 100644
--- a/widget/windows/nsNativeThemeWin.h
+++ b/widget/windows/nsNativeThemeWin.h
@@ -87,6 +87,8 @@ class nsNativeThemeWin : public Theme {
 
   bool ThemeNeedsComboboxDropmarker() override;
 
+  bool WidgetAppearanceDependsOnWindowFocus(StyleAppearance) override;
+
   nsNativeThemeWin();
 
  protected:
diff --git a/widget/windows/nsUXThemeConstants.h b/widget/windows/nsUXThemeConstants.h
index 44ce9ab34e20..af9375d7fb94 100644
--- a/widget/windows/nsUXThemeConstants.h
+++ b/widget/windows/nsUXThemeConstants.h
@@ -237,6 +237,8 @@ enum {
   WP_Count
 };
 
+enum FRAMESTATES { FS_ACTIVE = 1, FS_INACTIVE = 2 };
+
 enum {
   BS_NORMAL = 1,
   BS_HOT = 2,
diff --git a/widget/windows/nsUXThemeData.cpp b/widget/windows/nsUXThemeData.cpp
index b984689300b7..722695a0344f 100644
--- a/widget/windows/nsUXThemeData.cpp
+++ b/widget/windows/nsUXThemeData.cpp
@@ -92,6 +92,8 @@ const wchar_t* nsUXThemeData::GetClassName(nsUXThemeClass cls) {
       return L"Listview";
     case eUXMenu:
       return L"Menu";
+    case eUXWindowFrame:
+      return L"Window";
     default:
       MOZ_ASSERT_UNREACHABLE("unknown uxtheme class");
       return L"";
@@ -110,7 +112,7 @@ void nsUXThemeData::UpdateNativeThemeInfo() {
   HIGHCONTRAST highContrastInfo;
   highContrastInfo.cbSize = sizeof(HIGHCONTRAST);
   if (SystemParametersInfo(SPI_GETHIGHCONTRAST, 0, &highContrastInfo, 0)) {
-    sIsHighContrastOn = highContrastInfo.dwFlags & HCF_HIGHCONTRASTON;
+    sIsHighContrastOn = ((highContrastInfo.dwFlags & HCF_HIGHCONTRASTON) != 0);
   } else {
     sIsHighContrastOn = false;
   }
diff --git a/widget/windows/nsUXThemeData.h b/widget/windows/nsUXThemeData.h
index 8a308f341c1f..af67b0d5e23a 100644
--- a/widget/windows/nsUXThemeData.h
+++ b/widget/windows/nsUXThemeData.h
@@ -34,6 +34,7 @@ enum nsUXThemeClass {
   eUXHeader,
   eUXListview,
   eUXMenu,
+  eUXWindowFrame,
   eUXNumClasses
 };
 
diff --git a/widget/windows/nsWindow.cpp b/widget/windows/nsWindow.cpp
index 6b8807613735..7210c89d599a 100644
--- a/widget/windows/nsWindow.cpp
+++ b/widget/windows/nsWindow.cpp
@@ -2849,13 +2849,27 @@ bool nsWindow::UpdateNonClientMargins(bool aReflowWindow) {
     metrics.mOffset = metrics.DefaultMargins();
     metrics.mOffset.top = metrics.mCaptionHeight;
   } else if (sizeMode == nsSizeMode_Maximized) {
-    // We make the entire frame part of the client area. We leave the default
-    // frame sizes for left, right and bottom since Windows will automagically
-    // position the edges "offscreen" for maximized windows.
-    int verticalResize =
-        WinUtils::GetSystemMetricsForDpi(SM_CYFRAME, dpi) +
-        (hasCaption ? WinUtils::GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi)
-                    : 0);
+    // On Windows 10+, we make the entire frame part of the client area. We
+    // leave the default frame sizes for left, right and bottom since Windows
+    // will automagically position the edges "offscreen" for maximized windows.
+    //
+    // On versions prior to Windows 10, we add padding to the widget to
+    // circumvent a bug in DwmDefWindowProc (see
+    // nsNativeThemeWin::GetWidgetPadding).  We "undo" that padding in
+    // WM_NCCALCSIZE by adding the caption (as well as the sizing frame) to the
+    // client area.
+    //
+    // The padding is not needed on Win10+ because we handle window buttons
+    // non-natively in the theme.  It also does not work on Win10+ -- it exposes
+    // a new issue where widget edges would sometimes appear to bleed into other
+    // displays (bug 1614218).
+    int verticalResize = 0;
+    if (IsWin10OrLater()) {
+      verticalResize =
+          WinUtils::GetSystemMetricsForDpi(SM_CYFRAME, dpi) +
+          (hasCaption ? WinUtils::GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi)
+                      : 0);
+    }
 
     metrics.mOffset.top = metrics.mCaptionHeight - verticalResize;
 
@@ -4981,10 +4995,7 @@ bool nsWindow::ProcessMessageInternal(UINT msg, WPARAM& wParam, LPARAM& lParam,
     return true;
   }
 
-  // Glass hit testing w/custom transparent margins.
-  //
-  // FIXME(emilio): is this needed? We deal with titlebar buttons non-natively
-  // now.
+  // Glass hit testing w/custom transparent margins
   LRESULT dwmHitResult;
   if (mCustomNonClient &&
       DwmDefWindowProc(mWnd, msg, wParam, lParam, &dwmHitResult)) {
